<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chi-bin·blog</title>
  
  <subtitle>望着山川河流擎烛而走</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-15T10:50:16.674Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chi-bin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://yoursite.com/2019/10/15/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/15/Markdown常用语法/</id>
    <published>2019-10-15T09:51:34.000Z</published>
    <updated>2019-10-15T10:50:16.674Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/15/Markdown常用语法/kk.jpg" alt="kk"><a id="more"></a><br>语法代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br><span class="line"><span class="section">###### 这是六级标题</span></span><br><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">***这是斜体加粗的文字**</span>*</span><br><span class="line">~~这是加删除线的文字~~</span><br><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br><span class="line">---  分割线</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span>  分割线</span><br><span class="line"><span class="strong">*****</span></span><br><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可加可不加</span><br><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line">列表嵌套</span><br><span class="line">上一级和下一级之间敲三个空格即可</span><br><span class="line"><span class="bullet">* </span>表格</span><br><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line"><span class="bullet">- </span>有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/15/Markdown常用语法/kk.jpg&quot; alt=&quot;kk&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>linux学习篇</title>
    <link href="http://yoursite.com/2019/10/15/linux%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/15/linux学习篇/</id>
    <published>2019-10-15T08:56:05.000Z</published>
    <updated>2019-10-15T13:36:40.046Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/15/linux学习篇/linux.jpg" alt="linux"></p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试"><a href="#首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试" class="headerlink" title="首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试"></a>首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试</h2><p>win10 下开启 控制面板-&gt;程序-&gt;启用或关闭windows功能-&gt;适用于Linux的windows子系统-&gt;重启。<br>应用商店里搜索：linux，下载Ubuntu启动就可以了。<br><img src="/2019/10/15/linux学习篇/ubuntu.png" alt="ubuntu"><br>做一个简简单单的小测试吧，使用ps命令查看自己的控制台是哪个程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   34 tty1     00:00:00 bash</span><br><span class="line">   49 tty1     00:00:00 ps</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure><p><strong>我们都知道文档是很重要的，那么Linux系统早期发布的系统是通常没有纸质版的参考手册，可是联机文档一直是他的强项之一，怎么找到和使用之呢？</strong></p><ul><li>大多数的GUN实用程序都有-help命令显示帮助信息</li><li>使用man 如man man,man git,空格翻页，man password 将找到password在man页中对应的内容</li><li>appropos 使用关键字和appropos 可以查找某个任务的命令，appropos会在man页的顶行信息中找到搜索关键字，whatis 可以准确搜索，结果会是完全匹配的</li><li>info程序：显示使用程序的说明文档，空格翻页，/+字符串进行查找</li></ul><p><strong>linux更改密码</strong></p><ul><li>在命令行中输入passwd即可修改密码，系统会先询问你旧密码，之后输入新密码</li></ul><h1 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h1><h2 id="关于shell"><a href="#关于shell" class="headerlink" title="关于shell"></a>关于shell</h2><p><strong>shell的特殊字符</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; ; | * ? ' " ` [] () $ &lt;&gt; &#123;&#125; # / \ ! ~</span><br></pre></td></tr></table></figure><h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><p><strong>ls</strong></p><ul><li>显示文件名和目录名</li><li>可以执行 info ls 来看文档</li></ul><p><strong>cat</strong></p><ul><li>显示文本文件的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ vi gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ ls</span><br><span class="line">gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ cat gss</span><br><span class="line">各位小伙伴们大家好呀！</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p><strong>rm</strong></p><ul><li>删除文件</li><li>跟文件名在后面会直接删除，</li><li>rm -i file 这种命令会有提示询问是否删除</li></ul><p><strong>less,more</strong></p><ul><li>分页程序，当文件的内容超过一页的时候，使用之</li><li>less filename</li><li>more filename</li></ul><p><strong>hostname</strong></p><ul><li>显示正在使用的主机名字<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ hostname</span><br><span class="line">DESKTOP-4H90EP2</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><strong>cp</strong></p><ul><li>复制文件，对任何文件进行复制，包括文本文件或是可执行文件（二进制文件）</li><li>cp source-file(源文件) destinnation-file（目标文件名）</li><li>如果cp的目标文件是一个已经存在的文件，那么cp会重写这个文件，没有提示，所以要慎重的使用cp,同理使用 -i后缀可以有提示</li></ul><p><strong>mv</strong></p><ul><li>更改文件名</li><li>mv afilename newfilename</li><li>mv 也会覆盖文件，建议加-i</li></ul><p><strong>lpr</strong></p><ul><li>把文件放到打印序列中按行打印</li><li>lpr -P machenname filename 选择打印机打印file</li><li>lpq可以查看打印队列中的作业</li><li>lprm 88：把序号是88的作业删除</li></ul><p><strong>grep</strong></p><ul><li>查找字符串</li><li>grep ‘关键字’ filename</li><li>不止可以在文件中找</li></ul><p><strong>head</strong></p><ul><li>默认显示文件的前10行信息</li><li>month -数字 filename:显示文件的前几行</li><li>还可以按照块儿或者字符显示</li></ul><p><strong>tail</strong></p><ul><li>显示文件的尾部</li><li>与head类似</li><li>可以用这个监控逐渐增长的某个文件的内容</li></ul><p><strong>sort</strong></p><ul><li>将文件内容按行排序之后输出来，但是不改变文件内容</li><li>-u:使得排序列表的每一行都唯一</li><li>-n:对一列数排序</li></ul><p><strong>uniq</strong></p><ul><li>用来显示文件内容，对于重复的行只显示一行，不会改变源文件的内容</li><li>sort+uniq等同于带u的sort</li></ul><p><strong>diff</strong></p><ul><li>比较两个文件显示两者所有的不同之处</li><li>带上-u会说明比较得是哪两个文件</li><li>查看更多信息可以info</li></ul><p><strong>file</strong></p><ul><li>获得Linux系统中任何文件的内容信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ file gss</span><br><span class="line">gss: UTF-8 Unicode text</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><h2 id="管道：实现进程间的通信"><a href="#管道：实现进程间的通信" class="headerlink" title="管道：实现进程间的通信"></a>管道：实现进程间的通信</h2><ul><li>表示：|</li><li>把一个进程的结果当成另一个进程的输入传递进去</li><li>如sort months | head -4  把拍好序的month的前四行输出</li><li>管道是linux不可缺少的功能<h2 id="重要的四个程序"><a href="#重要的四个程序" class="headerlink" title="重要的四个程序"></a>重要的四个程序</h2></li></ul><p><strong>echo</strong></p><ul><li><p>显示文本</p></li><li><p>echo把命令行中除了echo的所有东西复制到屏幕上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span> hi</span><br><span class="line">hi</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span> i love linux</span><br><span class="line">i love linux</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span> 复读机</span><br><span class="line">复读机</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li><li><p>通过echo可以把输出重定向到文件中，如echo ‘hello’ &gt; gss,就是把echo放到gss中</p></li></ul><p><strong>date</strong></p><ul><li><p>显示当前的日期和时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ date</span><br><span class="line">Tue Oct 15 20:20:20 CST 2019</span><br></pre></td></tr></table></figure></li><li><p>跟一些参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%A %B %d"</span></span><br><span class="line">Tuesday October 15</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%A %b %d"</span></span><br><span class="line">Tuesday Oct 15</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%A %b %D"</span></span><br><span class="line">Tuesday Oct 10/15/19</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%a %b %D"</span></span><br><span class="line">Tue Oct 10/15/19</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p><strong>script</strong></p><ul><li>记录shell会话信息</li><li>键入script,就开始记录，键入exit结束记录</li><li>可以记下来命令行之间的交互内容，如<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ script</span><br><span class="line">Script started, file is typescript</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">"root"</span>), use <span class="string">"sudo &lt;command&gt;"</span>.</span><br><span class="line">See <span class="string">"man sudo_root"</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">gss@DESKTOP-4H90EP2:~$ whoami</span><br><span class="line">gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">Script <span class="keyword">done</span>, file is typescript</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ cat typescript</span><br><span class="line">Script started on 2019-10-15 20:33:27+0800</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">"root"</span>), use <span class="string">"sudo &lt;command&gt;"</span>.</span><br><span class="line">See <span class="string">"man sudo_root"</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">gss@DESKTOP-4H90EP2:~$ whoami</span><br><span class="line">gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">Script <span class="keyword">done</span> on 2019-10-15 20:33:54+0800</span><br></pre></td></tr></table></figure></li></ul><p><strong>todos</strong></p><ul><li>把linux中的文本文件转换成Windows格式</li><li>todos gss.txt<br>##压缩和归档文件</li></ul><p><strong>bzip2</strong></p><ul><li>这个软件适合重复信息很多的图片，如文本和图像，压缩效果很好</li><li>但是使用的时候，会删掉原来的文件，可以使用 bzip -k filename 来保留源文件</li><li>bzip2 filename   会自动生成一个filename.bz2压缩包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ bzip2 gss2</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ ls</span><br><span class="line">gss  gss2.bz2  sfile  typescript</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p><strong>bunzip2和bzcat</strong></p><ul><li>用来解压文件</li><li>同样的用法，注意也会删掉压缩包</li></ul><p><strong>tar</strong></p><ul><li>打包和解包文件</li><li>打包：tar -cvf afile bfile cfile</li><li>解包：tar -xvf xxx.tar</li><li>使用man可以查看更多的内容<h2 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h2></li></ul><p><strong>which和whereis</strong></p><ul><li><p>定位实用程序</p></li><li><p>一个概念：搜索路径：输入一个linux命令之后，shell将在一组目录下查找具有该名称的程序，并运行找到的第一个，这组目录被叫做搜索路径，可以更改，日后再讲（猜测是环境变量类似的），如果不改变，就只在标准路径下搜索，然后停止。</p></li><li><p>which：通过显示程序的完整路径来帮助查找之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">which</span> tar</span><br><span class="line">/bin/tar</span><br></pre></td></tr></table></figure></li><li><p>whereis:在标准路径下搜索与实用程序相关的文件</p></li><li><p>这俩只能报告在磁盘上的程序路劲，无法找到内置命令，要是想要确认命令是不是内置命令，可以使用type 如：type echo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">type</span> locate</span><br><span class="line">locate is hashed (/usr/bin/locate)</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">type</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>slocate/locate</strong></p><ul><li>搜索文件</li><li>用于在本地文件系统上搜索文件</li><li>locate file<h2 id="获取用户和系统信息"><a href="#获取用户和系统信息" class="headerlink" title="获取用户和系统信息"></a>获取用户和系统信息</h2>怎么显示正在使用系统的用户，以及显示他们在做什么，和系统如何运行的信息</li></ul><p><strong>who</strong></p><ul><li>最老的实用程序，给出登录到本地系统的用户列表，每个用户在使用的设备，和每个用户登录的时间。</li></ul><p><strong>w</strong></p><ul><li>当希望和本地系统上的其他用户通信的时候，会很有用，比who的功能更加强大，<h2 id="与其他用户进行通信"><a href="#与其他用户进行通信" class="headerlink" title="与其他用户进行通信"></a>与其他用户进行通信</h2></li></ul><p><strong>write</strong> </p><ul><li>给另一个登录用户发送消息</li></ul><p><strong>mesg</strong></p><ul><li>拒绝或接受消息</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/15/linux学习篇/linux.jpg&quot; alt=&quot;linux&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="http://yoursite.com/2019/10/11/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/10/11/java基础/</id>
    <published>2019-10-11T03:06:31.000Z</published>
    <updated>2019-10-11T04:15:27.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/11/java基础/fengmian.jpg" alt="封面"></p><a id="more"></a><h2 id="java类的修饰词"><a href="#java类的修饰词" class="headerlink" title="java类的修饰词"></a>java类的修饰词</h2><p>有 public ,private,protected,default<br><img src="/2019/10/11/java基础/zuyongyu.png" alt="修饰词作用域"></p><ul><li>public：无论是否在同一个包，谁都可以访问</li><li>protected:只有自己包的类，或是别的包的子类可以访问，别的包的非子类是不可以访问的，</li><li>default:当前类和同个包的文件可以访问。别的包不可以访问</li><li>private:只要自己才可以访问。只有内部类菜会用到但是不建议这么写<h2 id="成员变量修饰符"><a href="#成员变量修饰符" class="headerlink" title="成员变量修饰符"></a>成员变量修饰符</h2></li><li>public：指定该变量为公共的他可以被任何对象的方法访问</li><li>private：指定该变量只允许自己的类的方法访问，其他任何类中的方法（包括子类）都不能访问</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/11/java基础/fengmian.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="http://yoursite.com/2019/10/09/linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/10/09/linux命令/</id>
    <published>2019-10-09T12:23:16.000Z</published>
    <updated>2019-10-09T13:27:32.087Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/linux命令/feiji.jpg" alt="赛博朋克儿"></p><a id="more"></a><h2 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h2><p>1.sync:把内存中的数据写到硬盘中(每次关机之前重启之前都要执行)<br>2.shutdown -r now或rebot:立刻重启<br>3.shutdown -h now：立刻关机<br>4.shutdown -h 20:00 预定时间关机，如果今天过了预定的时间则明天这个时候关机<br>5.shutdown -h +10:预定时间关机，10分钟后关机。<br>6.shutdown -c:取消关机</p><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p>1.who am i:查看当前使用的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz9938t1plpjtmzr7adqz ~]<span class="comment"># who am i</span></span><br><span class="line">root     pts/0        2019-10-09 21:16 (117.152.78.143)</span><br></pre></td></tr></table></figure><p>2.who 或 w :查看所有终端<br>3.uname -m:显示机器的处理器架构<br>4.cat/proc/version 查看linux版本信息<br>5.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/linux命令/feiji.jpg&quot; alt=&quot;赛博朋克儿&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java内存模型</title>
    <link href="http://yoursite.com/2019/10/09/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/09/java内存模型/</id>
    <published>2019-10-09T11:34:46.000Z</published>
    <updated>2019-10-09T12:08:36.244Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/java内存模型/mei.jpg" alt="wind"></p><a id="more"></a><p><img src="/2019/10/09/java内存模型/jvm.jpg" alt="jvm"></p><ol><li>程序计数器：线程私有，记录的是正在执行的虚拟机字节码指令的地址。如果执行的是Native方法，则这个计数器的值为（undefined）,这是jvm中唯一一个不会有内存溢出的错误的区域</li><li>虚拟机栈：线程私有，生命周期和线程一致，描述的是java方法的内存模型，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表操作数栈，动态链接，方法出口等消息，每个方法从调用到执行结束，都是对应着一个栈帧从虚拟机中从入栈到出栈的过程。可能出现的错误：1. StackOverflowError(请求的栈的深度大于虚拟机的规定的栈的深度)2. OutOfMemoryError(虚拟机无法申请到足够的内存)</li><li>java堆：jvm中最大的一块儿，线程共享，主要是存放实例对象和数组。内部可以划分出多个线程私有的分配缓冲区，可以物理上不连续但是逻辑结构上需要连续。</li><li>java本地方法栈：为虚拟机使用到的本地方法服务，也会有StackOverflowError和OutOfMemoryError</li><li>方法区：属于共享内存区域，存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</li><li>运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，编译期和运行期（Sting的intern（）都可以将常量放到内存中）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/java内存模型/mei.jpg&quot; alt=&quot;wind&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat的面经</title>
    <link href="http://yoursite.com/2019/10/09/Tomcat%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/10/09/Tomcat的面经/</id>
    <published>2019-10-09T07:21:07.000Z</published>
    <updated>2019-10-09T11:09:38.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/Tomcat的面经/fan.jpg" alt="饭"> <img src="/2019/10/09/Tomcat的面经/fou.jpg" alt="fou"></p><a id="more"></a><p>总结一些从网上找到的各种有关于Tomcat的面试题目，做一个记忆</p><h2 id="Tomcat的缺省端口是多少，要怎么修改"><a href="#Tomcat的缺省端口是多少，要怎么修改" class="headerlink" title="Tomcat的缺省端口是多少，要怎么修改"></a>Tomcat的缺省端口是多少，要怎么修改</h2><p>缺省端口：8080<br>在conf文件夹中更改Host中的Connector的相关属性，端口号改成你需要的端口号码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="tomcat有几种部署方式"><a href="#tomcat有几种部署方式" class="headerlink" title="tomcat有几种部署方式"></a>tomcat有几种部署方式</h2><ul><li><p>直接把项目war包放在webapps目录下Tomcat会自动部署</p></li><li><p>在Server.xml中配置Context节点。</p></li><li><p>通过Catalina来进行配置：就是 cd 到 /usr/local/tomcat/apache-tomcat/conf/catatlina/localhost目录下，创建一个xml文件，该文件名字就是站点的名字，通过编写xml的方式来配置站点</p><h2 id="tomcat有哪几种Connector运行模式（以及各种模式优化方法）"><a href="#tomcat有哪几种Connector运行模式（以及各种模式优化方法）" class="headerlink" title="tomcat有哪几种Connector运行模式（以及各种模式优化方法）"></a>tomcat有哪几种Connector运行模式（以及各种模式优化方法）</h2><p>总共有三种运行模式<br>bio,nio,aio(nio.2),apr</p></li><li><p>传统的bio,同步阻塞的链接方式</p></li><li><p>设置maxThread属性的值//tomcatConnector使用的是多线程的模式，根据每台计算机的性能和内存大小不一样，一般可以放到400-500，最大可以放到800，默认只有两百</p></li><li><p>设置connector的maxSpareThreads属性，设置当线程超过某个值，tomcat就关闭不再需要的socket线程，默认50</p></li><li><p>acceptcount，指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数值的请求将不再被处理</p></li><li><p>ConnectionTimeout属性：网络连接超时的时间默认20000毫秒，可以设置为30000毫秒</p></li><li><p>进阶的nio(同步阻塞的io)</p></li><li><p>指定使用NIO模型来接受HTTP请求 nio或是aio</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protocol=”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol=”HTTP/1.1” </span><br><span class="line">acceptorThreadCount=”2” 使用NIO模型时接收线程的数目</span><br></pre></td></tr></table></figure></li><li><p>apr模式（我不太了解的模式，才知道。。。）</p></li><li><p>Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。（额，对于动静分离的项目，布吉岛有什么用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      &lt;Connector connectionTimeout="20000" port="8000" protocol="HTTP/1.1" redirectPort="8443" uriEncoding="utf-8"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- minProcessors最小空闲连接线程数--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- maxProcessors最大连接线程数--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">redirectPort</span>=<span class="string">"8443</span></span></span><br><span class="line"><span class="tag"><span class="string">        maxThreads=“500” </span></span></span><br><span class="line"><span class="tag"><span class="string">        minSpareThreads=“100” </span></span></span><br><span class="line"><span class="tag"><span class="string">        maxSpareThreads=“200”</span></span></span><br><span class="line"><span class="tag"><span class="string">        acceptCount="</span><span class="attr">200</span>"</span></span><br><span class="line"><span class="tag">        <span class="attr">enableLookups</span>=<span class="string">"false"</span>       </span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tomcat容器是如何创建servlet实例的？用到了什么原理？"><a href="#tomcat容器是如何创建servlet实例的？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet实例的？用到了什么原理？"></a>tomcat容器是如何创建servlet实例的？用到了什么原理？</h2><p>当容器启动的时候，会读取项目中的web.xml读取servlet注册信息，然后将每个应用注册的servlet都进行加载，通过反射的方式实例化</p><h2 id="tomcat怎么优化"><a href="#tomcat怎么优化" class="headerlink" title="tomcat怎么优化"></a>tomcat怎么优化</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">优化连接配置.这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，修改连接数，关闭客户端dns查询。</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line"></span><br><span class="line">URIEncoding=”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</span><br><span class="line"></span><br><span class="line">maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</span><br><span class="line"></span><br><span class="line">minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</span><br><span class="line"></span><br><span class="line">enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</span><br><span class="line"></span><br><span class="line">connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</span><br><span class="line"></span><br><span class="line">maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</span><br><span class="line"></span><br><span class="line">acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</span><br><span class="line"></span><br><span class="line">maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。</span><br><span class="line"></span><br><span class="line">通常Windows是1000个左右，Linux是2000个左右。</span><br><span class="line">可以看到如果把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</span><br><span class="line"></span><br><span class="line">enableLookups=”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</span><br><span class="line"></span><br><span class="line">disableUploadTimeout ：类似于Apache中的keeyalive一样</span><br><span class="line"></span><br><span class="line">给Tomcat配置gzip压缩(HTTP压缩)功能</span><br><span class="line"></span><br><span class="line">compression=”on” compressionMinSize=”2048″</span><br><span class="line"></span><br><span class="line">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</span><br><span class="line"></span><br><span class="line">HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</span><br><span class="line"></span><br><span class="line">1)compression=”on” 打开压缩功能</span><br><span class="line"></span><br><span class="line">2)compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</span><br><span class="line"></span><br><span class="line">3)noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</span><br><span class="line"></span><br><span class="line">4)compressableMimeType=”text/html,text/xml”　压缩类型</span><br></pre></td></tr></table></figure><h2 id="tomcat-内存调优"><a href="#tomcat-内存调优" class="headerlink" title="tomcat 内存调优"></a>tomcat 内存调优</h2><p>内存的调整是在catalina.sh中的调整一下java_opts变量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。 </span><br><span class="line">具体设置如下： </span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4" </span><br><span class="line">其各项参数如下： </span><br><span class="line">-Xmx3550m：设置JVM最大可用内存为3550M。 </span><br><span class="line">-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 </span><br><span class="line">-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 </span><br><span class="line">-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 </span><br><span class="line">-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 </span><br><span class="line">-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 </span><br><span class="line">-XX:MaxPermSize=16m:设置持久代大小为16m。 </span><br><span class="line">-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br></pre></td></tr></table></figure><h2 id="tomcat-垃圾回收"><a href="#tomcat-垃圾回收" class="headerlink" title="tomcat 垃圾回收"></a>tomcat 垃圾回收</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 </span><br><span class="line">-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 </span><br><span class="line">-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 </span><br><span class="line">-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 </span><br><span class="line">-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 </span><br><span class="line">并发收集器（响应时间优先） </span><br><span class="line">示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 </span><br><span class="line">-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 </span><br><span class="line">-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 </span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</span><br></pre></td></tr></table></figure><h2 id="怎么监视Tomcat的内存使用情况"><a href="#怎么监视Tomcat的内存使用情况" class="headerlink" title="怎么监视Tomcat的内存使用情况"></a>怎么监视Tomcat的内存使用情况</h2><p> 使用jdk自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等。<br> 还可以下载Gc来看更详细的的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/Tomcat的面经/fan.jpg&quot; alt=&quot;饭&quot;&gt; &lt;img src=&quot;/2019/10/09/Tomcat的面经/fou.jpg&quot; alt=&quot;fou&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://yoursite.com/2019/10/09/Tomcat/"/>
    <id>http://yoursite.com/2019/10/09/Tomcat/</id>
    <published>2019-10-09T05:04:16.000Z</published>
    <updated>2019-10-09T07:06:01.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/Tomcat/tom.png" alt="tomcat"></p><a id="more"></a><h2 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h2><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，也是一个Servlet/JSP容器。Tomcat作为Servlet容器，负责处理客户端请求，把请求传送给Servlet，并将Servlet的响应返回给客户端。同时也具备处理静态页面的能力。多与Apache或是nginx搭配使用</p><h2 id="Tomcat的构成和处理请求的流程"><a href="#Tomcat的构成和处理请求的流程" class="headerlink" title="Tomcat的构成和处理请求的流程"></a>Tomcat的构成和处理请求的流程</h2><ul><li><p>Tomcat是一个基于组件的服务器，它的构成组件都是可配置的。其各个组件都在Tomcat安装目录下的../conf/server.xml文件中配置。</p></li><li><p>通过之后的配置文件的源码解读，我们将会了解到tomcat的核心组件主要有两个，一个是Connector,还有一个是Container</p></li><li><p>根据我的理解就是，connector负责在某一个指定的端口上面监听客户的请求，接受浏览器发过来的tcp链接请求，创建一个request和response对象负责交换数据，然后会产生一个线程来处理这个请求，并把这两个对象传给Engine,从Engine中获得相应再传给客户端。多线程的思想是Connector设计的核心。</p></li><li><p>而container是什么呢？就是容器的父接口，简单理解的话就是搭载了servlet应用程序的地方。他的体系结构如下图<br><img src="/2019/10/09/Tomcat/jiegou.jpg" alt="jiegou"></p></li><li><p>是一个责任链的设计模式主要由4个子容器组件构成，分别是Engine,Host,Context,Wrapper</p><ol><li>Engine容器比较简单，定义了一些基本的关联关系链接到host容器。</li><li>Host是Engine容器的子容器，一个Host在Engine中代表着一个虚拟主机。这个虚拟主机的作用就是运行多个应用，他负责安装和展开这些应用。并且标识这个应用以便能够区分它们，他的子容器通常是Context它除了关联子容器之外还有一些主机的相关的信息。</li><li>Context代表了servlet的Context，他具备了servlet运行的基本条件，理论上有了context就可以运行servlet了，他最重要的功能就是管理里面的servlet实例，而servlet的实例在Context中是以wrapper的形式出现的。Context通过request来找到对应的wrapper来执行。</li><li>Wrapper，代表了一个servlet的实例，负责管理一个servlet的生命周期，包括装载，初始化，执行，以及资源的回收，他的实现类是StandardWrapper，他实现了一个初始servlet的信息类servletconfig。wrapper就是tomcat的最底层了，他没有子容器。</li></ol></li><li><p>除此之外，Tomcat中还有其他重要的组件，如安全组件security、logger日志组件、session、mbeans、naming等其他组件。这些组件共同为Connector和Container提供必要的服务。</p></li><li><p>接下来我们模拟一下当有一个请求来到tomcat时会发生什么<br><img src="/2019/10/09/Tomcat/liucheng.jpg" alt="流程"></p><ol><li>用户在浏览器中输入网址localhost:8080/test/index.jsp，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得；</li><li>Connector把该请求交给它所在的Service的Engine（Container）来处理，并等待Engine的回应；</li><li>Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；</li><li>.Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）；</li><li>path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL Pattern为*.jsp的Servlet，对应于JspServlet类；</li><li>程序地干活</li><li>Context把执行完之后的HttpServletResponse对象返回给Host</li><li>层层返回</li></ol></li></ul><h2 id="配置文件的用途和含义"><a href="#配置文件的用途和含义" class="headerlink" title="配置文件的用途和含义"></a>配置文件的用途和含义</h2><p><img src="/2019/10/09/Tomcat/peizhi.png" alt="peizhi"><br>可以看到有Context.xml,Server.xml,tomcat-users.xml,以及web.xml这些配置文件。</p><h3 id="Context-xml文件解释"><a href="#Context-xml文件解释" class="headerlink" title="Context.xml文件解释"></a>Context.xml文件解释</h3><p>首先需要明确Context.xml是做什么的，他是Tomcat公用的环境配置文件，tomcat会定时的去扫描这个文件，发现文件被修改了之后（时间戳改变）就会自动的重新加载这个文件，而不需要重启tomcat，推荐在$CATALINA_BASEconf/context.xml进行独立配置。就是说在单独的context中进行配置而不在server.xml中去做配置。因为server.xml是不可动态加载的资源。要重启服务器才可以重新加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/eml"</span> <span class="attr">docBase</span>=<span class="string">"eml"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadbale</span>=<span class="string">"true"</span> <span class="attr">privileged</span>=<span class="string">"true"</span>&gt;</span>  </span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span>  </span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/eml.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span> #监控资源文件，如果web.xml || eml.xml改变了，则自动重新加载改应用。  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"jdbc/testSiteds"</span> 　　#表示指定的<span class="attr">jndi</span>名称  </span></span><br><span class="line"><span class="tag">    <span class="attr">auth</span>=<span class="string">"Container"</span> 　　#表示认证方式，一般为<span class="attr">Container</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">maxActive</span>=<span class="string">"100"</span> 　　#连接池支持的最大连接数  </span></span><br><span class="line"><span class="tag">    <span class="attr">maxIdle</span>=<span class="string">"40"</span> 　　　　#连接池中最多可空闲<span class="attr">maxIdle</span>个连接  </span></span><br><span class="line"><span class="tag">    <span class="attr">maxWait</span>=<span class="string">"30000"</span> 　　#连接池中连接用完时,新的请求等待时间,毫秒  </span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">"txl"</span> 　　　#表示数据库用户名  </span></span><br><span class="line"><span class="tag">    <span class="attr">password</span>=<span class="string">"123456"</span> 　　#表示数据库用户的密码  </span></span><br><span class="line"><span class="tag">    <span class="attr">driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span> 　　#表示<span class="attr">JDBC</span> <span class="attr">DRIVER</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost:3306/testSite"</span> /&gt;</span> 　　#表示数据库URL地址  </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><p>context.xml的三个作用范围</p><ul><li>tomcat server级别：  在/conf/context.xml里配置</li><li>Host级别：  在/conf/Catalina/${hostName}里添加context.xml，继而进行配置</li><li>web app 级别：  在/conf/Catalina/${hostName}里添加${webAppName}.xml，继而进行配置</li></ul><h3 id="Server-xml文件解释"><a href="#Server-xml文件解释" class="headerlink" title="Server.xml文件解释"></a>Server.xml文件解释</h3><p>server.xml是对tomcat的设置，可以设置端口号，添加虚拟机这些的，是对服务器的设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 全局命名资源，来定义一些外部访问资源，其作用是为所有引擎应用程序所引用的外部资源的定义 --!&gt; </span></span><br><span class="line"><span class="comment">    &lt;Resource name="UserDatabase" auth="Container"</span></span><br><span class="line"><span class="comment">              type="org.apache.catalina.UserDatabase"</span></span><br><span class="line"><span class="comment">              description="User database that can be updated and saved"</span></span><br><span class="line"><span class="comment">              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="line"><span class="comment">              pathname="conf/tomcat-users.xml" /&gt;</span></span><br><span class="line"><span class="comment">  &lt;/GlobalNamingResources&gt;</span></span><br><span class="line"><span class="comment">  &lt;Service name="Catalina"&gt;</span></span><br><span class="line"><span class="comment">      &lt;Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; </span></span><br><span class="line"><span class="comment">   &lt;!-- 修改HTTP/1.1的Connector监听端口为80.客户端通过浏览器访问的请求，只能通过HTTP传递给tomcat。还可以设置server与URIEncoding参数 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;Engine name="Catalina" defaultHost="test.com"&gt;--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 修改当前Engine，默认主机是，localhost  --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">   # Realm组件，定义对当前容器内的应用程序访问的认证，通过外部资源UserDatabase进行认证 </span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义了一个主机，域名是localhost，应用程序的目录是/webapps,设置自动部署解压--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"> &lt;!--   定义一个Valve组件，用来记录tomcat的访问日志，日志存放目录为：/web/www/logs如果定义为相对路径则是相当于$CATALINA_HOME，并非相对于appBase，这个要注意。定义日志文件前缀为www_access.并以.log结尾，pattern定义日志内容格式，具体字段表示可以查看tomcat官方文档   --&gt; </span><br><span class="line">               prefix="localhost_access_log" suffix=".txt"</span><br><span class="line">               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span><br><span class="line">   <span class="comment">&lt;!--可以在这里添加别名&lt;Alias&gt;www.test.com&lt;/Alias&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;Context path="" docBase="www/" reloadable="true" /&gt; </span></span><br><span class="line"><span class="comment">定义该应用程序，访问路径""，即访问www.test.com即可访问，网页目录为：相对于appBase下的www/，即/web/www，并且当该应用程序下web.xml或者类等有相关变化时，自动重载当前配置，即不用重启tomcat使部署的新应用程序生效  --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">  Host name="manager.test.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; </span><br><span class="line">        <span class="comment">&lt;!--   定义一个主机名为man.test.com，应用程序目录是$CATALINA_HOME/webapps,自动解压，自动部署   --&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span> <span class="attr">allow</span>=<span class="string">"172.16.100.*"</span> /&gt;</span> </span><br><span class="line">          <span class="comment">&lt;!--   定义远程地址访问策略，仅允许172.16.100.*网段访问该主机，其他的将被拒绝访问  --&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"/web/bbs/logs"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">prefix</span>=<span class="string">"bbs_access."</span> <span class="attr">suffix</span>=<span class="string">".log"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span> </span><br><span class="line">          <span class="comment">&lt;!--   定义该主机的访问日志      --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">Host</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个 server 有一个 service，一个 service 里有多个 connector 和一个 engine，不同的 connector 除了端口可能不同，协议也可能不同。多个connector 对应一个 engine。　　engine 代表我们应用程序的容器。一个 engine 中有一个到多个 host，一个host 代表我们的一个虚拟主机。host 里又有一个到多个 context，一个 context 代表了一个应用程序的虚拟子站点。</p><h3 id="tomcat-users-xml文件解释"><a href="#tomcat-users-xml文件解释" class="headerlink" title="tomcat-users.xml文件解释"></a>tomcat-users.xml文件解释</h3><p>这个是使用tomcatMannager才需要配置的属性。</p><h3 id="web-xml文件解释"><a href="#web-xml文件解释" class="headerlink" title="web.xml文件解释"></a>web.xml文件解释</h3><p>Web应用程序描述文件，都是关于是Web应用程序的配置文件。所有Web应用的 web.xml 文件的父文件。<br>这个文件是基本不用配置的，如果要支持cgi的话，要在这里面吧cgi的那一段儿注释掉。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/Tomcat/tom.png&quot; alt=&quot;tomcat&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2019/10/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/02/排序算法/</id>
    <published>2019-10-02T03:56:53.000Z</published>
    <updated>2019-10-09T00:59:59.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>今天打算梳理一下我所了解的排序算法，不同的排序算法所拥有的时间复杂度，空间复杂度，是否稳定，都不一样，所以在不同的情况下有不同的应用场景，做个大概的总结。<br><img src="/2019/10/02/排序算法/all.png" alt="排序算法"></p><a id="more"></a><h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><ul><li>基本思想：把最小的元素或是最大的元素，依次放到数组的最右边，直到全部有序，每次比较发现不符合排序规则，就进行交换</li><li>时间复杂度：O(n^2),平方阶</li><li>稳定性：是</li><li>代码(升序排列)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a[j+<span class="number">1</span>];</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="快速排序（冒泡的升级版本）"><a href="#快速排序（冒泡的升级版本）" class="headerlink" title="快速排序（冒泡的升级版本）"></a>快速排序（冒泡的升级版本）</h2><ul><li>基本思想：通过一趟排序，把数组分成两个部分，其中一部分比另一部分都小，然后再分别以这两个部分为基础部分进行递归，直到退出的时候，就是有序的。</li><li>时间复杂度：平均和最优的情况都是线性对数阶 O(nlogn)，最坏的情况是O(n^2)</li><li>稳定性：否</li><li>代码(升序排列)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=left;</span><br><span class="line"><span class="keyword">int</span> r=right;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//当左边的标志比右边的小的时候继续循环，直到会面</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;a[mid])&#123;l++;&#125;<span class="comment">//在左边找到一个比中间值大的数</span></span><br><span class="line"><span class="keyword">while</span>(r&gt;a[mid])&#123;r--;&#125;<span class="comment">//在右边找到一个比中间值小的数</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//当左边的标志大于右边的时候，说明分好了两个部分</span></span><br><span class="line">&#125;<span class="comment">//没做就是还没有分好，并且找到了这样的两个数</span></span><br><span class="line"><span class="keyword">int</span> temp=a[l];<span class="comment">//交换</span></span><br><span class="line">a[l]=a[r];</span><br><span class="line">a[r]=temp;</span><br><span class="line"><span class="keyword">if</span>(a[l]==a[mid])&#123;r--;&#125;<span class="comment">//发现交换之后，左边与中值相等，右边就左移一位</span></span><br><span class="line"><span class="keyword">if</span>(a[r]==a[mid])&#123;l++;&#125;<span class="comment">//右边与中值相等，就把左边右移一位</span></span><br><span class="line">&#125;<span class="comment">//做完之后就分成了连个部分。然后把这两个部分作为基础部分再次递归</span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="comment">//中间的这个值，实际上已经是两个部分的中值了，既已经可以认定是有序的了，所以可以不进递归</span></span><br><span class="line">l++;<span class="comment">//预防了两边的冲突</span></span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&lt;right)&#123;quicksort(a,l,right);&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;left)&#123;quicksort(a,left,r);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul><li>基本思想：每趟把未排序的数组的第一个元素插入到前面的有序序列中去</li><li>时间复杂度：最优:O(n),平均：O(n^2),最差：O(n^2)</li><li>空间复杂度：常数阶</li><li>稳定性：稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> index=i-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> val=a[i];</span><br><span class="line"><span class="keyword">while</span>((index&gt;=<span class="number">0</span>)&amp;&amp;val&lt;a[index])&#123;</span><br><span class="line">a[index+<span class="number">1</span>]=a[index];</span><br><span class="line">index--;</span><br><span class="line">&#125;</span><br><span class="line">a[index+<span class="number">1</span>]=val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="希尔排序（插入排序增强版）"><a href="#希尔排序（插入排序增强版）" class="headerlink" title="希尔排序（插入排序增强版）"></a>希尔排序（插入排序增强版）</h2><ul><li>基本思想：通过解决较小的数要比较较多次的问题，设置增量多次插入排序，得到较好地时间复杂度</li><li>时间复杂度：最坏：O(n^    2),平均复杂度O(n^1.3),实际应用的事务中，希尔排序的效率还是很高的</li><li>空间复杂度：常数阶</li><li>稳定性 :不稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> gap=a.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;a.length;a++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i-gap;j&gt;=<span class="number">0</span>;j-=gap) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+gap]) &#123;</span><br><span class="line">temp=a[j];</span><br><span class="line">a[j]=a[j+gap];</span><br><span class="line">a[j+gap]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul><li>基本思想：每次选择当前未排序的序列中最小的元素放在已排好序列的最后</li><li>时间复杂度：最坏和平均：O(n^2)，最好：线性阶</li><li>空间复杂度常数阶</li><li>稳定性：不稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> index=i;</span><br><span class="line"><span class="keyword">int</span> min=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;min)&#123;</span><br><span class="line">min=a[j];</span><br><span class="line">index=j;</span><br><span class="line">&#125;</span><br><span class="line">a[index]=a[i]</span><br><span class="line">a[i]=min;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="堆排序（选择排序的加强版）"><a href="#堆排序（选择排序的加强版）" class="headerlink" title="堆排序（选择排序的加强版）"></a>堆排序（选择排序的加强版）</h2><ul><li>基本思想：使用大顶堆或是小顶堆的思想来优化选择排序中的选择部分<br>  首先，把数组思维化一颗数，则第i个元素的两个子节点分别是2k+1,2k+2</li></ul><ul><li>时间复杂度：最好最坏平均：线性对数阶O(nlog2 N)</li><li>空间复杂度：常数阶</li><li>稳定性：不稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/    * 主方法，负责  </span><br><span class="line"> * 调成一个大顶堆，交换，调整*/</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;<span class="comment">//传进来之后，首先调成一个大顶堆</span></span><br><span class="line">adjustheap(a,i,a.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--) &#123;</span><br><span class="line">temp=a[j];  <span class="comment">//把堆顶放到数组末尾</span></span><br><span class="line">a[j]=a[<span class="number">0</span>];</span><br><span class="line">a[<span class="number">0</span>]=temp;</span><br><span class="line">adjustheap(a,<span class="number">0</span>,j);  <span class="comment">//最后的已经有序元素下标是j，堆最后的元素下标为j-1,堆的长度是j</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**完成将以i指向的节点为根节点的树调整成大顶堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i表示非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> alength表示对多少个元素(堆的长度)进行调整，alength在实际的生产环境中是在不断地减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustheap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> alength)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>;k&lt;alength;k=k*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(k+<span class="number">1</span>&lt;alength&amp;&amp;a[k]&lt;a[k+<span class="number">1</span>]) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[k]&gt;temp) &#123;</span><br><span class="line">a[i]=a[k];</span><br><span class="line">i=k;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事实上是选取俩个子节点中较大的那一个，然后赋值给a[i]</span></span><br><span class="line">a[i]=temp;</span><br><span class="line"><span class="comment">//当结束了 循环之后，已经局部完成了大顶堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>基本思路：采用分治算法的思想，先分再治，程序分成拆分数组和合并数组的两个部分，采用一个辅助数组来得以实现</li><li>时间复杂度：最优最差平均的时间复杂度都是线性对数阶</li><li>空间复杂度：N(元素个数)</li><li>稳定性：稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归分开，排序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">mergetsort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//向左边递归归并</span></span><br><span class="line">mergetsort(a,left,mid,temp);</span><br><span class="line"><span class="comment">//向右边递归归并</span></span><br><span class="line">mergetsort(a,mid+<span class="number">1</span>,right,temp);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">merget()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merget</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=left;<span class="comment">//左边索引</span></span><br><span class="line"><span class="keyword">int</span> j=mid+<span class="number">1</span>;<span class="comment">//右边索引</span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)&#123;<span class="comment">//合并两个有序序列直到一边结束</span></span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">temp[t]=a[i];</span><br><span class="line">i++;t++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">temp[t]=a[j];</span><br><span class="line">j++;t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把剩下一边的元素填充到temp中去</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">temp[t]=a[i];</span><br><span class="line">t++;i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">temp[t]=a[j];</span><br><span class="line">t++;j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把temp中的元素复制回到a中</span></span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> templeft=left;</span><br><span class="line"><span class="keyword">while</span>(templeft&lt;=right)&#123;</span><br><span class="line">a[templeft]=temp[t];</span><br><span class="line">templeft++;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ul><li>基本思路：经典的空间换时间的算法，通过桶来盛放每个元素相同位上的数字，达到进行比较大小的目的。</li><li>时间复杂度：如题头图</li><li>稳定性：稳定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redixsort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">max = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义同，但是为了防止溢出，每个桶的大小都定成a.length</span></span><br><span class="line"><span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>][a.length];</span><br><span class="line"><span class="keyword">int</span>[] bucketelementindex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (max + <span class="string">""</span>).length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> digitofelement = a[j] / n % <span class="number">10</span>;</span><br><span class="line">bucket[digitofelement + <span class="number">10</span>][bucketelementindex[digitofelement + <span class="number">10</span>]] = a[j];</span><br><span class="line">bucketelementindex[digitofelement + <span class="number">10</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bucketelementindex[k] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketelementindex[k]; l++) &#123;</span><br><span class="line">a[index] = bucket[k][l];</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bucketelementindex[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;今天打算梳理一下我所了解的排序算法，不同的排序算法所拥有的时间复杂度，空间复杂度，是否稳定，都不一样，所以在不同的情况下有不同的应用场景，做个大概的总结。&lt;br&gt;&lt;img src=&quot;/2019/10/02/排序算法/all.png&quot; alt=&quot;排序算法&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构和算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>servlet大概</title>
    <link href="http://yoursite.com/2019/09/29/servlet%E5%A4%A7%E6%A6%82/"/>
    <id>http://yoursite.com/2019/09/29/servlet大概/</id>
    <published>2019-09-29T03:48:37.000Z</published>
    <updated>2019-10-05T08:57:16.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。"><a href="#servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。" class="headerlink" title="servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。"></a>servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。</h2><a id="more"></a><h2 id="首先，servlet不是一个框架，他是服务器端运行的一个程序，是个被编译好的java类，web容器（web服务器）的启动需要依靠servlet，当web服务器开始执行的时候，servlet类就被初始化，"><a href="#首先，servlet不是一个框架，他是服务器端运行的一个程序，是个被编译好的java类，web容器（web服务器）的启动需要依靠servlet，当web服务器开始执行的时候，servlet类就被初始化，" class="headerlink" title="首先，servlet不是一个框架，他是服务器端运行的一个程序，是个被编译好的java类，web容器（web服务器）的启动需要依靠servlet，当web服务器开始执行的时候，servlet类就被初始化，"></a>首先，servlet不是一个框架，他是服务器端运行的一个程序，是个被编译好的java类，web容器（web服务器）的启动需要依靠servlet，当web服务器开始执行的时候，servlet类就被初始化，</h2><h2 id="Java-Servlet-是运行在带有支持-Java-Servlet-规范的解释器的-web-服务器上的-Java-类。"><a href="#Java-Servlet-是运行在带有支持-Java-Servlet-规范的解释器的-web-服务器上的-Java-类。" class="headerlink" title="Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。"></a>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</h2><ol><li>Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</li><li>这些类实现 Java Servlet 和 JSP 规范。在写本教程的时候，二者相应的版本分别是 Java Servlet 2.5 和 JSP 2.1。</li><li>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。<h2 id="Java-Servlet-通常情况下与使用-CGI（Common-Gateway-Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于-CGI，Servlet-有以下几点优势："><a href="#Java-Servlet-通常情况下与使用-CGI（Common-Gateway-Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于-CGI，Servlet-有以下几点优势：" class="headerlink" title="Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势："></a>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</h2></li><li>性能明显更好。</li><li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li><li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li><li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li><li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。&quot;&gt;&lt;a href=&quot;#servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。&quot; class=&quot;headerlink&quot; title=&quot;servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。&quot;&gt;&lt;/a&gt;servlet是作为来自web浏览器或者是其他http客户端的请求和http服务器上的数据库或是应用程序的中间层。&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>SpringMvc学习总结</title>
    <link href="http://yoursite.com/2019/09/27/SpringMvc%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/27/SpringMvc学习总结/</id>
    <published>2019-09-27T02:30:01.000Z</published>
    <updated>2019-10-05T08:57:27.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a>流程图解</h2><p><img src="/2019/09/27/SpringMvc学习总结/SpringMvc%E6%B5%81%E7%A8%8B.png" alt="图解"></p><a id="more"></a><h3 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h3><ol><li>客户端发送请求到DispatcherServlet(拦截器)</li></ol><ul><li><p>要了解为什么DispatcherServlet可以拦截所有的请求和底层，就要先了解servlet是什么。<a href="/serlet大概">servlet大概</a><br><img src="/2019/09/27/SpringMvc学习总结/diceng.png" alt="DispatcherServlet"></p></li><li><p>而继承了HTTPServlet的DispatcherServlet，在其父类FrameWorkServlet中实现了HTTPServlet的doGet，doPost等方法，代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因为实现了这些方法，所以拦截器DispatcherServlet可以拦截所有的请求。</p></li></ul><ol start="2"><li>DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler或是controller。返回一个Handler或是controller。</li></ol><ul><li>因为有次面试被为什么给折磨到崩裂开来，现在碰到这种问题，我都要问问自己为什么<br><img src="/2019/09/27/SpringMvc学习总结/handelermapping.png" alt="HandlerMapping"><br>SimpleUrlHandlerMapping类通过配置文件把url映射到Controller类<br>DefaultAnnotationHandlerMapping通过注解把URL映射到Controller类</li></ul><ol start="3"><li>解析到对应的Handler或者是controller后开始由HandlerAdapter适配器处理。帮助DispatcherServlet处理映射请求处理程序的适配器。他的作用是根据HandlerMapping返回的Handler对象（controller对象）然后去适配具体的方法。<br><img src="/2019/09/27/SpringMvc学习总结/HandlerAdapter.png" alt="HandlerAdapter"><br>AnnotationMethodHandlerAdapter：通过注解，把请求URL映射到Controller类的方法上。</li></ol><p>4.处理器完成任务了之后，会返回一个ModeAndView对象，Mode是返回的数据对象，而view是逻辑上的view。</p><ul><li>什么是modeAndview呢？<br>ModelAndView是Spring中标准的类，完全是Spring自己封装的对象。<br>实际上是两个部分一个是view，在我的理解来看就是一个标识id的作用，用来告知viewResolver去哪里找到view文件。而Mode由addObject()来决定的，他的本质是HashMap，键值对；</li></ul><p>5.ViewResolver会根据逻辑上的view来查找实际上的view</p><ul><li>就是根据那个标识id来去查找实际的view。具体怎么实现的呢？<br><img src="/2019/09/27/SpringMvc学习总结/vrs.png" alt="viewResolver"><br>首先InternalResourceViewResolver extends（继承）了 UrlBasedViewResolver；然后顺便说，把用于显示（view）的jsp文件放在WEB-INF文件夹下是一种安全的做法，这样不能通过url直接access这些jsp，只能通过Controller java类来访问它们。</li></ul><p>6.DispatcherServlet 会根据找到的实际的view然后把mode给它，通过浏览器表达给用户。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流程图解&quot;&gt;&lt;a href=&quot;#流程图解&quot; class=&quot;headerlink&quot; title=&quot;流程图解&quot;&gt;&lt;/a&gt;流程图解&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/09/27/SpringMvc学习总结/SpringMvc%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;图解&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SpringMvc" scheme="http://yoursite.com/tags/SpringMvc/"/>
    
  </entry>
  
  <entry>
    <title>windows 当前目录下打开控制台</title>
    <link href="http://yoursite.com/2019/06/01/windows-%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%93%E5%BC%80%E6%8E%A7%E5%88%B6%E5%8F%B0/"/>
    <id>http://yoursite.com/2019/06/01/windows-当前目录下打开控制台/</id>
    <published>2019-06-01T14:40:49.000Z</published>
    <updated>2019-10-05T08:56:13.796Z</updated>
    
    <content type="html"><![CDATA[<ul><li>第一步： 打开你的目录</li><li>第二步： Shift + 右键</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;第一步： 打开你的目录&lt;/li&gt;
&lt;li&gt;第二步： Shift + 右键&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Hexo上传的图片在网页上无法显示的解决办法</title>
    <link href="http://yoursite.com/2019/06/01/Hexo%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/01/Hexo上传的图片在网页上无法显示的解决办法/</id>
    <published>2019-06-01T13:46:59.000Z</published>
    <updated>2019-10-05T08:57:56.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>hexo 建立的博客，想传图片进去，就在source目录下面创建了一个image发现不行，然后又在头像的目录下面创建了一个sorimg的目录，把图片放进去了，这次运行起来主页终于有图片了，可是当点进“展开全文”的标签时，内容页图片丢失..<br>想要完美的插入一张图片</p><a id="more"></a><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>找到你自己博客根目录下的_config.yml里的post_asset_folder，把这个选项从false改成true。<br><code>post_asset_folder: true</code></li><li>根目录下下载 上传图片的插件，运行npm（或者cnpm）<br><code>npm install hexo-asset-image --save</code></li><li>创建你的文章，就会发现现在的source目录下面不只有md文件，还会多出来一个文件夹<br><code>PS C:\Users\GSS\git\chi-bin_bo&gt; hexo new &quot;windows 当前目录下打开控制台&quot;</code><br><img src="/2019/06/01/Hexo上传的图片在网页上无法显示的解决办法/a.png" alt="开始的地方"></li><li>把想要添加的图片放进该文件夹中，md中如下调用<br><code>![alt](a.png)</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;hexo 建立的博客，想传图片进去，就在source目录下面创建了一个image发现不行，然后又在头像的目录下面创建了一个sorimg的目录，把图片放进去了，这次运行起来主页终于有图片了，可是当点进“展开全文”的标签时，内容页图片丢失..&lt;br&gt;想要完美的插入一张图片&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>我的博客</title>
    <link href="http://yoursite.com/2019/05/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2019/05/31/我的第一次博客/</id>
    <published>2019-05-31T13:36:40.000Z</published>
    <updated>2019-10-09T11:03:44.061Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/05/31/我的第一次博客/avator.jpg" alt="开始的地方"></p><a id="more"></a><h3 id="创建博客的原因"><a href="#创建博客的原因" class="headerlink" title="创建博客的原因"></a>创建博客的原因</h3><p> 平时可能不管是写代码或者是搭建环境的时候，甚至是装个软件的时候可能都会有各种各样的问题，这一次解决了可能下一次就又忘记了，所以每次解决问题的时候都看别人的博客，就起了想要自己写博客的念头。</p><h3 id="可能包括的内容"><a href="#可能包括的内容" class="headerlink" title="可能包括的内容"></a>可能包括的内容</h3><p>可能有一些我觉得很有趣的思路或是过程，可能是一些配置环境的搭建问题，或者是我想到什么就瞎写一通，杂七杂八，。</p><p>海涵了诸位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/05/31/我的第一次博客/avator.jpg&quot; alt=&quot;开始的地方&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
