<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chi-bin·blog</title>
  
  <subtitle>望着山川河流擎烛而走</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-20T03:38:02.077Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chi-bin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于git的自动部署</title>
    <link href="http://yoursite.com/2019/11/20/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/11/20/关于git的自动部署/</id>
    <published>2019-11-20T03:31:50.000Z</published>
    <updated>2019-11-20T03:38:02.077Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/20/关于git的自动部署/fengpi.jpg" alt="封面"></p><a id="more"></a><p>aaa</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/11/20/关于git的自动部署/fengpi.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>jvm调整</title>
    <link href="http://yoursite.com/2019/11/19/jvm%E8%B0%83%E6%95%B4/"/>
    <id>http://yoursite.com/2019/11/19/jvm调整/</id>
    <published>2019-11-19T04:49:15.000Z</published>
    <updated>2019-11-19T05:49:27.509Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/19/jvm调整/jvm.jpg" alt="封皮"></p><a id="more"></a><p>##有关jvm堆内存的一次调整记录<br>    项目中需要一次读入一个很大的列表，大概5-6万条左右，本地跑着没有啥问题，然后拉到生产环境上面去，就只返回一个200的code，啥都没有，赶紧去翻log，发现有一个异常java.lang.outofMemory,按理说应该就没啥好说的了，动手到tomcat的catelina.bat或者是linux的catelina.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set "JAVA_OPTS=-Xms512m -Xmx1024m"</span><br></pre></td></tr></table></figure><p>按理说这么一搞，重启一下，应该就没问题了，堆的大小应该就够用了<br>然而事情哪有这么简单，有的人用winserver做服务器，启动，关闭，重启都在系统服务里做了，倒是方便，可是你会发现不管怎么配置catelina.bat，那个讨人厌的oom都不会消失折腾了好久终于发现，windowsserver系统服务中的启动关闭，用的都是tomcat.exe,读取的设置压根就不是catelina，而是系统的注册表，而且这个注册表的结构和普通的windows的结构还不是很一样，最终在这个目录下面<br><code>HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Apache Software Foundation\Procrun 2.0\Tomcat\Parameters\Java</code><br>找到了那两个值的设置位置。<br>啥都不想说了，心中一万个草泥马飞奔而过。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/11/19/jvm调整/jvm.jpg&quot; alt=&quot;封皮&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>关于mybatis的批量插入</title>
    <link href="http://yoursite.com/2019/11/19/%E5%85%B3%E4%BA%8Emaven%E7%9A%84%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/"/>
    <id>http://yoursite.com/2019/11/19/关于maven的批量插入/</id>
    <published>2019-11-19T04:48:49.000Z</published>
    <updated>2019-11-19T05:52:48.066Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/19/关于maven的批量插入/fengpi.jpg" alt="封面"></p><a id="more"></a><p>##关于mybatis向数据库中批量插入数据的问题<br>    最近项目中有一个需求是通过读入一个excel生成对象插入到mysql中，项目结合了mybatis，在导入数据量很少的情况下，一切都显得其乐融融，很完美，但是数据量变成了5w条之后，就出现了各种各样的问题，写一下记录一下。<br><strong>实现思路：</strong></p><ol><li>文件读取之后对excel进行解析，得到一个对象的list。</li><li>mybatis中配置一个foreach的插入。</li><li>写好dao接口和service之后在controller中进行调用<br>关键的代码是foreach的插入<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertForeach"</span>&gt;</span></span><br><span class="line">insert into learnedstudent(stu_id,stu_name,stu_class,stu_college,stu_school)</span><br><span class="line">values</span><br><span class="line">   <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"stu"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">   (</span><br><span class="line">   #&#123;stu.stu_no&#125;,</span><br><span class="line">   #&#123;stu.stu_name&#125;,</span><br><span class="line">   #&#123;stu.stu_class&#125;,</span><br><span class="line">   #&#123;stu.stu_college&#125;,</span><br><span class="line">   #&#123;stu.stu_school&#125;</span><br><span class="line">   )</span><br><span class="line">   <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>碰到的问题</strong><br>小数据量的情况下速度很快，一点问题没有，但是5w多条之后就会报一个query.package过长的错误，估计意思就是中间的对象过多，一次的语句量过大。<br>解决的方法就是去数据库中，打开命令窗口</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show VARIABLES like '%max_allowed_packet%';</span><br><span class="line">+<span class="comment">--------------------------+------------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">--------------------------+------------+</span></span><br><span class="line">| max_allowed_packet | 4194304 |</span><br><span class="line">| slave_max_allowed_packet | 1073741824 |</span><br><span class="line">+<span class="comment">--------------------------+------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>max_allowed_packet就是有关这一项的设置参数，做如下设置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set max_allowed_packet=100*1024*1024;</span><br></pre></td></tr></table></figure><p>即大小设为100M报错消失</p><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p>当数据量更大的时候怎么办，内存的大小终究是有限的，网络上有一种解决方法<br>思路：<br>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p><p>(1)在全局配置文件Mybatis-springmvc.xml(根据个人的配置方式不同写入)中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个可以批量执行的sqlSession --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"executorType"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2)在serviceImpl中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//批量保存员工</span></span><br><span class="line">   <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">batchEmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">   </span><br><span class="line">           <span class="comment">//批量保存执行前时间</span></span><br><span class="line">           <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">   </span><br><span class="line">           EmployeeMapper mapper=    sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">               mapper.addEmp(<span class="keyword">new</span> Employee(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>),<span class="string">"b"</span>,<span class="string">"1"</span>));</span><br><span class="line">   </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">long</span> end=  System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">long</span> time2= end-start;</span><br><span class="line">           <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">           System.out.println(<span class="string">"执行时长"</span>+time2);</span><br><span class="line">           </span><br><span class="line">          </span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">int</span>) time2;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>mapper和mapper.xml如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;    </span><br><span class="line"><span class="comment">//批量保存员工</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">addEmp</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.agesun.mybatis.dao.EmployeeMapper"</span></span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmp"</span>&gt;</span></span><br><span class="line">        insert into employee(lastName,email,gender)</span><br><span class="line">        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/11/19/关于maven的批量插入/fengpi.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaEE" scheme="http://yoursite.com/tags/JavaEE/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>关于maven项目整poi读取excel</title>
    <link href="http://yoursite.com/2019/11/17/%E5%85%B3%E4%BA%8Emaven%E9%A1%B9%E7%9B%AE%E6%95%B4poi%E8%AF%BB%E5%8F%96excel/"/>
    <id>http://yoursite.com/2019/11/17/关于maven项目整poi读取excel/</id>
    <published>2019-11-17T01:45:52.000Z</published>
    <updated>2019-11-17T02:54:34.579Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/17/关于maven项目整poi读取excel/winter.jpg" alt="封皮"></p><a id="more"></a><h1 id="关于ssm的maven项目整合poi读取excel"><a href="#关于ssm的maven项目整合poi读取excel" class="headerlink" title="关于ssm的maven项目整合poi读取excel"></a>关于ssm的maven项目整合poi读取excel</h1><p>   记录一下项目中用到poi读取excel的一次经历吧，防止日后需要</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><pre><code>+ maven方式导入poi相关包+ controller中获取到要上传的文件，转化成输入流。+ 准备一个工具类根据文件后缀名称识别excel版本+ 根据不同的版本采用不同的构造方式得到Workbook对象+ 根据传入的Workbook对象，得到相关的sheet，和行还有单元格，读入相关的对象，存到数据库中。</code></pre><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p><strong>maven导入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SXSSHWorkbook适用于处理大量数据。</p><p><strong>判断版本的工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 验证EXCEL文件 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateExcel</span><span class="params">(String filePath)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (filePath == <span class="keyword">null</span> || !(isExcel2003(filePath) || isExcel2007(filePath))) &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// @描述：是否是2003的excel，返回true是2003   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExcel2003</span><span class="params">(String filePath)</span>  </span>&#123;    </span><br><span class="line">         <span class="keyword">return</span> filePath.matches(<span class="string">"^.+\\.(?i)(xls)$"</span>);    </span><br><span class="line">     &#125;    </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//@描述：是否是2007的excel，返回true是2007   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExcel2007</span><span class="params">(String filePath)</span>  </span>&#123;    </span><br><span class="line">         <span class="keyword">return</span> filePath.matches(<span class="string">"^.+\\.(?i)(xlsx)$"</span>);    </span><br><span class="line">     &#125;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>controller中获得相关的输入流和文件的文件名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Msg <span class="title">uploadExcel</span><span class="params">(@RequestBody MultipartFile file,HttpServletRequest request)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到上传文件名称</span></span><br><span class="line">String fileName=file.getOriginalFilename();</span><br><span class="line"><span class="keyword">if</span>(!ExcelUtils.validateExcel(fileName)) &#123;</span><br><span class="line"><span class="keyword">return</span>  Msg.error(<span class="string">"文件错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">Workbook wb = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        InputStream is = file.getInputStream();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span>(ExcelUtils.isExcel2003(fileName)) &#123;</span><br><span class="line">wb=<span class="keyword">new</span> HSSFWorkbook(is);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">wb=<span class="keyword">new</span> XSSFWorkbook(is);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;LearnedStudent&gt; list=getlist(wb);</span><br><span class="line"><span class="keyword">int</span> num=upservice.insertForeach(list);</span><br><span class="line"><span class="keyword">return</span> Msg.success(<span class="string">"成功清空并导入！"</span>).add(<span class="string">"number"</span>, num);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)  &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> Msg.error(<span class="string">"导入失败，请检查表格格式！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>得到sheet和row还有cell的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sheet sheet=wb.getSheetAt(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">//得到第一个sheet</span></span><br><span class="line"><span class="keyword">int</span> rownum=sheet.getPhysicalNumberOfRows();</span><br><span class="line"><span class="comment">//得到sheet表的行数</span></span><br><span class="line">cellnum  =sheet.getRow(<span class="number">0</span>).getPhysicalNumberOfCells();</span><br><span class="line"><span class="comment">//得到sheet表的列数</span></span><br><span class="line"> Row row = sheet.getRow(i);</span><br><span class="line"> <span class="comment">//得到行</span></span><br><span class="line"> Cell cell = row.getCell(j);</span><br><span class="line"><span class="comment">//得到cell</span></span><br><span class="line"><span class="comment">//根据需要采用循环的方式一行一行读cell</span></span><br></pre></td></tr></table></figure><p>另外考虑到以后可能会用到更大数据量的情况，附上大数据量处理的连接<br><a href="https://blog.csdn.net/whandgdh/article/details/80267674" target="_blank" rel="noopener">csdn的一位博主</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/11/17/关于maven项目整poi读取excel/winter.jpg&quot; alt=&quot;封皮&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaEE" scheme="http://yoursite.com/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>关于一个令牌验证的框架</title>
    <link href="http://yoursite.com/2019/11/16/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E4%BB%A4%E7%89%8C%E9%AA%8C%E8%AF%81%E7%9A%84%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/11/16/关于一个令牌验证的框架/</id>
    <published>2019-11-16T08:12:52.000Z</published>
    <updated>2019-11-16T08:55:17.521Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/16/关于一个令牌验证的框架/bridge.jpg" alt="封皮"></p><a id="more"></a><h2 id="JwtPermission"><a href="#JwtPermission" class="headerlink" title="JwtPermission"></a>JwtPermission</h2><p> 找一个小项目，因为时间原因，所以找了一个令牌验证的框架，令人欣喜的是还有权限验证的部分，十分感谢原作者，在这里写一下使用过程中我的问题。<br> 基于jjwt实现的一套用于前后端分离项目的权限管理，实现基于token验证的Java权限框架，参考shiro设计，用法与shiro相近，简单实用！<br><a href="https://gitee.com/kingsmart/JwtPermission" target="_blank" rel="noopener">源码地址</a></p><ul><li>具体用法：<ul><li><ol><li>在springMvc中集成</li></ol></li><li><ol start="2"><li>配置相关的角色类和缓存类，建议使用redis，角色类是可以在token中集成用户的角色相关信息。使用相关的注解就可以控制相关的接口的访问权限。贼好用。</li></ol></li><li><ol start="3"><li>相关登录的controller中使用框架生成token</li></ol></li><li><ol start="4"><li>继承的方式书写异常类。springmvc中配置bean</li></ol></li></ul></li><li>注意的点:<ul><li>请求头或是参数里面设置的名称只能是token</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/11/16/关于一个令牌验证的框架/bridge.jpg&quot; alt=&quot;封皮&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaEE" scheme="http://yoursite.com/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习篇</title>
    <link href="http://yoursite.com/2019/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/20/操作系统复习篇/</id>
    <published>2019-10-20T06:02:10.000Z</published>
    <updated>2019-11-16T08:10:02.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/20/操作系统复习篇/girls.jpg" alt="叫我封皮"></p><a id="more"></a><p><img src="/2019/10/20/操作系统复习篇/com.png" alt="计算机组成"></p><h1 id="为什么要学习操作系统"><a href="#为什么要学习操作系统" class="headerlink" title="为什么要学习操作系统"></a>为什么要学习操作系统</h1><ul><li>加深对计算机OS的理解，优化编程。可以借鉴计算机os的思路和算法，概念和技巧可以推广到其他领域。</li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><ul><li>本质：大型的软件系统。对内负责计算机全部软件，硬件资源的管理，控制和协调并发活动，实现信息的存储和保护。对外，为用户使用计算机提供方便的界面。最终使计算机系统实现高效率和高自动化。</li></ul><h1 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h1><h2 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h2><ul><li>指的是两个或者多个事件在同一时间间隔内发生，在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行。</li><li>有效的改善了系统的利用率和提高了系统的吞吐量，但它使系统复杂化，操作系统必须具有控制和管理各种并发活动的能力。<h2 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h2></li><li>操作系统和多个用户是共同使用计算机中的资源的，所以对资源的合理调配是保证并发执行有效的重要的前提。</li><li>互斥共享方式：系统中的某些资源像是打印机，磁带机等等因为结果不能混乱，所以一段时间内只允许一个进程访问该资源。这种资源我们一般叫做临界资源或者是独占资源。</li><li>同时访问的方式：允许一段时间内多个进程同时访问（宏观上）<h2 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h2></li><li>把一个物理上的设备，转换成若干个逻辑上的对应物。</li><li>用于实现虚拟的技术，叫做虚拟技术</li><li>OS中如虚拟处理机，虚拟内存，虚拟外部设备和虚拟信道等。</li></ul><ul><li>虚拟机处理技术：通过多道程序设计技术，让多道程序并发执行的方法</li><li>虚拟存储器技术：通过这个技术，把物理存储器转成虚拟存储器，以便于从逻辑上来扩充存储器的容量。</li><li>虚拟设备技术：比如虚拟光驱<h2 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h2></li></ul><ul><li>多道程序的执行，并不是一气呵成的，而是每个进程开始和结束的时间都不确定，不是同步完成的</li></ul><h1 id="操作系统主要功能"><a href="#操作系统主要功能" class="headerlink" title="操作系统主要功能"></a>操作系统主要功能</h1><h2 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h2><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h2 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/20/操作系统复习篇/girls.jpg&quot; alt=&quot;叫我封皮&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础学习篇</title>
    <link href="http://yoursite.com/2019/10/19/SQL%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/19/SQL学习篇/</id>
    <published>2019-10-19T02:03:23.000Z</published>
    <updated>2019-11-16T08:00:07.116Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/19/SQL学习篇/winter.jpg" alt="winter"></p><a id="more"></a><h1 id="关系数据库概述"><a href="#关系数据库概述" class="headerlink" title="关系数据库概述"></a>关系数据库概述</h1><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><ul><li>数据库系统的组成：数据库，数据库管理系统（用户和操作系统之间的，用于管理数据库的软件），硬件系统，数据库管理员，用户  这个五个方面</li><li>数据处理的抽象描述：<table><thead><tr><th align="center">现实世界</th><th align="center">信息世界</th><th align="center">数据世界</th></tr></thead><tbody><tr><td align="center">事务</td><td align="center">实体集</td><td align="center">文件</td></tr><tr><td align="center"></td><td align="center">实体</td><td align="center">记录</td></tr><tr><td align="center">特性</td><td align="center">属性</td><td align="center">字段</td></tr><tr><td align="center">唯一特征</td><td align="center">键</td><td align="center">关键字</td></tr></tbody></table></li><li>数据模型:</li><li><ul><li>结构数据模型：反映了数据的逻辑结构及存储结构，包括层次模型，网状模型，和关系模型</li></ul></li><li><ul><li>信息模型：反映了实体和实体之间的联系（e-r图）<h2 id="关系数据库基本概念"><a href="#关系数据库基本概念" class="headerlink" title="关系数据库基本概念"></a>关系数据库基本概念</h2></li></ul></li><li>外模式：用户模式或者子模式，定义了允许用户操作的数据</li><li>模式: 模式也称为概念模式或者数据库模式，是数据库中全部数据逻辑结构的描述，概念模式以某种数据模型为基础，并用模式语言定义这些内容。概念模式可以看成是现实世界中的实体在具体数据库系统中的实现，概念模式与具体的应用程序无关，同时也不涉及数据的存储细节和硬件环境。</li><li>内模式：存储模式，是对数据物理结构和存储方式的描述，比如数据记录怎么存储，顺序存储还是按照索引存储，索引用什么方式组织等等<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2></li><li><strong>域</strong>：一组具有相同数据类型的值的集合。如，整数，实数，指定长度的字符串集合，介于某个取值范围的整数，{男，女}、介于某个取值范围的日期</li><li><strong>笛卡尔积</strong>：就是每个都组成一个新组<br>D1:{张海，刘邦}，D2：{自动化，信息工程}，D3{A,B,C}<br>则他们三个的笛卡尔积是D1*D2*D3<br>D{<br>  (张海，自动化，A)，(张海，自动化，B),(张海，自动化，C)<br>  (张海，信息工程，A),(张海，信息工程，B),(张海，信息工程，C)<br>  (刘邦，自动化，A)，(刘邦，自动化，B),(刘邦，自动化，c)<br>  (刘邦，信息工程，A)，(刘邦，信息工程，B),(刘邦，信息工程，c)<br>}</li><li><strong>关系</strong>:是笛卡尔积的有限的子集，无限关系在数据库中是没有意义的。</li><li><strong>元组</strong>:关系中的每个元素就是关系的元组，通常用t表示</li><li><strong>关系的表示</strong>:关系可以用一个二维表来表示，表的每一行对应一个元组，表的每一列对应一个域。</li><li><strong>属性</strong>:关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性</li><li><strong>码</strong>：候选码，要是关系中的某一属性组的值能唯一地标识一个元组，就是候选码。主码：如果一个关系有多个候选码，就选择一个作为主码。</li><li><strong>规范化</strong></li><li><ul><li>第一范式：每行和每列要求只有一个交点，就是所有的属性都必须是单值。但是记录可以重复</li></ul></li><li><ul><li>第二范式：要求每一个非键码的列都必须取决于整个主键码。而且要求唯一不空</li></ul></li><li><ul><li>第三范式：要求非键码列不能依赖于另一个非键码列</li></ul></li><li><ul><li>bcnf：没有传递依赖</li></ul></li><li><ul><li>第四范式：禁止在主码和非键码之间存在独立的一对多的关系</li></ul></li></ul><h1 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h1><h2 id="SQL功能和特性，以及语法分类"><a href="#SQL功能和特性，以及语法分类" class="headerlink" title="SQL功能和特性，以及语法分类"></a>SQL功能和特性，以及语法分类</h2><ul><li>非过程化语言，能让用户在不考虑数据存储方式的情况下就能按照自己的需求在高层层次的数据结构上操作。<br>特点</li><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>语言简洁，易学易用</li><li>同一种语法结构提供两种使用方式</li><li><strong>分类</strong><table><thead><tr><th align="center">SQL语法类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">属性词</td><td align="center">在SQL命令中用来指明所要选择的记录的方式，如all，top，和distinct等</td></tr><tr><td align="center">声明</td><td align="center">针对SQL Parameter或者是ParameterQuery的名称与数据类型做声明</td></tr><tr><td align="center">条件句子</td><td align="center">在SQL的查询中，利用一些表达式定义出查询的条件，以缩小寻找的范围，如where</td></tr><tr><td align="center">运算符</td><td align="center">在SQL的查询中，与Operation共同组成表达式（Expression）如between…and运算符与Inner join操作数。</td></tr><tr><td align="center">函数</td><td align="center">一些常见的 SQL 常见的函数，如avg（）</td></tr><tr><td align="center">SQL语句</td><td align="center">可以说是SQL语法的主体，用来对一个特定的数据库发出指示，并返回相关的数据</td></tr></tbody></table></li></ul><h2 id="SQL数据类型"><a href="#SQL数据类型" class="headerlink" title="SQL数据类型"></a>SQL数据类型</h2><pre><code>SQL-92主要包括数值类数据 ，字符型数据，时期数据，二进制数据，货币数据，空数据，逻辑数据和自定义数据类型等类型</code></pre><p><strong>数值类型</strong></p><ul><li>INT,BIGINT,SMALLINT,TINYINT,整数类型</li><li>DECIMAL（总长度等于精度）,NUMERI进去C（如定义一个数据类型是精度为 6，标度值是2 的，就要用到这个NUMERIC(6,2) 就可以存1234.56，舍入过程采取四舍五入制十进制）精确数值类型</li><li>FLOAT,REAL,DOUBLE PRECISION类型，近似数值型数据</li></ul><p><strong>字符型</strong></p><ul><li>char(N)：定长字符串</li><li>varchar（N):变长字符串</li><li>nchar(N):固定长度的宽字符串。</li><li>nvarchar(N):可变长度的宽字符串类型</li><li>text：字符型数据</li><li>ntext：宽字符类型</li></ul><p><strong>日期</strong></p><ul><li>DATETIME:用于表示时间或者日期的数据类型都属于DATETIME类型。每一种DATETIME数据类型都有他自己的用于获取值的长度和它所保存信息的手段。如天，月，分钟，秒，秒的小数等，实际上，随着格式的不一样，这个东西可能有不同的表现形式</li><li>DATE：允许没有参数，如精度，DATE的字段包括年月日，长度是10个字符。</li><li>TIME,TIME WITH,TIME ZONE,TIMESTAMP,TIMESTAMP,WITH TIMEZONE,INTERVAL,OVERLAPS</li></ul><p><strong>二进制数据类型</strong></p><ul><li>binary(N)</li><li>varbinary(N)</li><li>bit 类型</li></ul><p><strong>货币</strong></p><ul><li>Money</li><li>Smallmoney</li></ul><p><strong>空类型</strong></p><ul><li>Null</li></ul><p><strong>逻辑值</strong></p><ul><li>BOOLEAN|BLOB</li></ul><p><strong>自定义数据类型</strong></p><h2 id="SQL表达式"><a href="#SQL表达式" class="headerlink" title="SQL表达式"></a>SQL表达式</h2><h2 id="SQL标识符"><a href="#SQL标识符" class="headerlink" title="SQL标识符"></a>SQL标识符</h2><h2 id="SQL变量，常量"><a href="#SQL变量，常量" class="headerlink" title="SQL变量，常量"></a>SQL变量，常量</h2><h2 id="SQL语句概述"><a href="#SQL语句概述" class="headerlink" title="SQL语句概述"></a>SQL语句概述</h2><h2 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h2><h1 id="数据查询篇"><a href="#数据查询篇" class="headerlink" title="数据查询篇"></a>数据查询篇</h1><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h1 id="数据更新篇"><a href="#数据更新篇" class="headerlink" title="数据更新篇"></a>数据更新篇</h1><h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><h2 id="方案操作"><a href="#方案操作" class="headerlink" title="方案操作"></a>方案操作</h2><h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><h2 id="视图操作"><a href="#视图操作" class="headerlink" title="视图操作"></a>视图操作</h2><h2 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h2><h1 id="安全管理系列"><a href="#安全管理系列" class="headerlink" title="安全管理系列"></a>安全管理系列</h1><h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/19/SQL学习篇/winter.jpg&quot; alt=&quot;winter&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式</title>
    <link href="http://yoursite.com/2019/10/17/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/17/java设计模式/</id>
    <published>2019-10-17T12:02:31.000Z</published>
    <updated>2019-10-19T08:42:29.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/17/java设计模式/meat.jpg" alt="设计模式"></p><a id="more"></a><h1 id="Java设计模式"><a href="#Java设计模式" class="headerlink" title="Java设计模式"></a>Java设计模式</h1><h2 id="java反射技术"><a href="#java反射技术" class="headerlink" title="java反射技术"></a>java反射技术</h2><ul><li>java反射技术的应用十分广泛，它可以配置：类的全限定名，方法，和参数，完成对象的初始化，甚至是反射某些方法，IOC的基本原理也是基于反射。</li></ul><p><strong>通过反射构建对象</strong></p><ul><li><p>java中允许通过反射配置信息来构建对象，比如ReflectServiceImpl类，如下代码所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lean.ssm.chapter2.reflect</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectServiceImpl</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.err.println(<span class="string">"hello"</span>+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后通过反射的方式去构建这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReflectServiceImp <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">ReflectServiceImp object =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">object =(ReflectServiceImp)</span><br><span class="line">Class.forName(<span class="string">"com.lean.ssm.chapter2.reflect.ReflectServiceImpl"</span>).newInstance;</span><br><span class="line"><span class="comment">//这个方法传入一个类型的全路径的名字(也就是带包的完整名字)，会返回一个字节码类型(也就是Class类型)的实例</span></span><br><span class="line"><span class="comment">//然后再用这个字节码类型的实例clazz调用newInstance()方法会返回一个Object类型的对象</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException|InstantiationException|IllegalAccessException ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里的代码，就是生成一个对象，然后将其返回。先是给object注册了一个全限定名，然后通过newInstance方法初始化了一个类对象。</p></li><li><p>如果构造函数是有参的构造函数，就要做一下改动了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.lean.ssm.chapter2.reflect.ReflectServiceImpl"</span>).getConstructor(String.class).newInstance;</span><br></pre></td></tr></table></figure></li></ul><p><strong>为啥要用反射，我直接new一个不行吗？</strong><br>当然可以，事实上反射生成对象和你new一个对象是等价的，而且可能反射生成对象的开销还会更大一点，但是如果你的对象类不是写死的呢，可能后面更新换了更好的一个类，而各种类里头new了多少你不知道，那咋更新文件嘞，一个个去找显然不现实，可是这里classforname后面跟的是个参数，如果我直接更改这个参数，事情就会周很多。</p><ul><li>刚刚描述的就是反射的优点–解耦。降低程序的耦合度这很重要。比如SpringIOC容器，就是使用反射的。</li></ul><p><strong>反射方法</strong> </p><ul><li>之前有讲过，不仅类可以反射来实例化，方法也可反射，反射方法之前要获取方法对象。得到了方法才能够去反射。</li></ul><h2 id="动态代理模式和责任链模式"><a href="#动态代理模式和责任链模式" class="headerlink" title="动态代理模式和责任链模式"></a>动态代理模式和责任链模式</h2><p><strong>动态代理模式和责任链模式不管是在Spring还是说在Mybatis中都有重要的应用。</strong></p><ul><li>动态代理的意义在于生成一个占位（又称代理对象），来代理真实对象，从而控制真实对象的访问。就是公司商务和程序员的关系，客户肯定是找商务谈事情，而不是找程序员，商务和程序员就是代理的关系。。</li><li>代理他要分成两个步骤</li><li><ul><li>代理对象和真实对象建立代理关系</li></ul></li><li><ul><li>实现代理对象的代理逻辑方法。<br>java中有多种动态代理技术，比如JDK,CGLIB,javassist，ASM，其中最常用的有两种：JDK，CGLIB理论相似</li></ul></li></ul><p><strong>JDK动态代理</strong></p><ul><li><p>是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象。所以先定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWord</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后提供一个实现类来实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImp</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是最简单的java接口和实现类的关系，此时可以开始动态代理了，按照我们之前的分析，我们需要先建立起来代理对象和真实的服务对象的关系，然后实现代理逻辑</p></li><li><p>在JDK动态代理中，要实现代理逻辑类必须去实现java.lang.reflect.InvocationHandler接口，它里面定义了一个invoke方法，并提供接口数组用于下挂代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="comment">//真实对象</span></span><br><span class="line"><span class="keyword">private</span> Object target=<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">建立代理对象和真实对象之间的关系，并且返回一个代理对象</span></span><br><span class="line"><span class="comment">@param target 真实对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> object <span class="title">bind</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.target=target;</span><br><span class="line">   <span class="keyword">return</span> Proxy.newProxyInstance(target.getclass().getClassLoader(),targre.getClass().getInterfaces,<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *代理方法逻辑，</span></span><br><span class="line"><span class="comment">   @param proxy：代理对象</span></span><br><span class="line"><span class="comment">   @param method:当前调度方法。</span></span><br><span class="line"><span class="comment">   @param args :当前方法参数</span></span><br><span class="line"><span class="comment">   @return 代理结果返回</span></span><br><span class="line"><span class="comment">   @throws Throwable:异常</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"进入代理逻辑方法"</span>);</span><br><span class="line">  System.out.println(<span class="string">"在调度真实对象之前的服务"</span>);</span><br><span class="line">  Object obj=method.invoke(target,args);</span><br><span class="line">  System.out.println(<span class="string">"在调度真实对象之后的服务"</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上述代码中，bind建立了代理对象和真实对象之间的关系。</p></li><li><p>invoke方法实现了代理逻辑方法</p></li></ul><p><strong>CGLIB</strong></p><ul><li>JDK动态代理必须提供接口才能使用， 在一些不能提供接口的环境中，只能采用其他第三方的技术，比如CGLIB动态代理他的优点在于不需要提供接口。只要一个非抽象类就可以实现动态代理</li></ul><p><strong>拦截器</strong></p><ul><li>由于动态代理一般都比较难以理解，所以程序设计者会设计一个拦截器接口供开发者使用。开发者只要知道拦截器接口的方法含义和作用就可以了，不用知道动态代理是怎样实现的。</li><li>就是封装了动态代理的具体方法，而只暴露出来拦截器的相关接口供开发人员使用</li></ul><p><strong>责任链模式</strong></p><ul><li>当一个对象在一条链上被多个拦截器拦截处理时，我们把这种设计模式称为拦截器处理。</li><li>优点，可以在传递链上增加新的拦截器，增加拦截逻辑，缺点是会增加反射和代理，性能不高。</li></ul><p><strong>观察者模式</strong></p><ul><li>又叫做发布订阅模式，是对象的行为模式，定义了一种多对多的依赖关系，让多个观察者对象同时监视着被观察者对象的状态，当被观察者装袋发生变化的时候，会通知所有的观察者，让他自动更新自己。</li><li>可以解耦，更加易于拓展。</li></ul><p><strong>工厂模式和抽象工厂模式</strong></p><ul><li>在大部分情况下，我们都是用new来创建对象的,而工厂模式就是你告诉我需要什么样的类，我来给你生产</li><li>普通工厂模式:只需要知道工厂的产对象的方法，告诉工厂要什么对象，就可以得到结果</li><li>抽象工厂模式：向客户端提供一个接口，使得客户端在不必指定产品的具体情况下创建多个产品族中的产品对象。就是把各种工厂抽象成一个抽象工厂，这个工厂可以进行管理就想nginx代理各种服务器，外部只访问到nginx</li></ul><p><strong>建造者模式</strong></p><ul><li>建造者模式属于对象的创建模式，可以将一个产品内部和产品的生成过程分割开来。从而使一个建造过程生成具有不同的内部表象的产品对象。</li><li>解决可能一种对象有太多种不同的表现形式不好使用工厂或是new的问题</li><li>通过一步一步构建个体对象而把整体对象构建出来。</li></ul><p><strong>单例模式</strong></p><ul><li>就是一个类只有一个实例</li><li>单例类必须自己创建自己的实例</li><li>单例类必须为其他对象提供唯一的实例</li><li><strong>好处</strong>：节省内存，方便垃圾回收。</li><li>它可以保证一个类只有一个实例，并且提供全局访问点。</li><li>懒汉式：只有在有对象要访问的时候才会创建实例。</li><li>饿汉式：一开始就创建。</li><li>什么情况下使用单例模式：控制资源的使用。通过线程同步的方式来控制资源的并发访问。节约资源，通信媒介。</li><li>实际上，配置信息类、管理类、控制类、门面类、代理类通常被设计为单例类。像Java的Struts、Spring框架，.Net的Spring.Net框架，以及Php的Zend框架都大量使用了单例模式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/17/java设计模式/meat.jpg&quot; alt=&quot;设计模式&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习篇</title>
    <link href="http://yoursite.com/2019/10/17/Redis%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/17/Redis学习篇/</id>
    <published>2019-10-17T11:13:36.000Z</published>
    <updated>2019-10-19T09:11:54.166Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/17/Redis学习篇/cat.jpg" alt="cat"></p><a id="more"></a><h1 id="最流行的NoSQL–Redis"><a href="#最流行的NoSQL–Redis" class="headerlink" title="最流行的NoSQL–Redis"></a>最流行的NoSQL–Redis</h1><ul><li><p>Redis是当前互联网世界中最为流行的NoSQL。NoSQL可以在很大的程度上提升互联网系统的性能。它具备一定持久层的功能。也可以作为一种缓存工具。作为持久层，它存储的数据是半结构化的，这就意味着计算机在读入内存中有更少的规则，读入的速度更快，对于那些结构化。多范式规则的数据库系统而言，它更具有性能优势。作为缓存，它可以支持大数据存入内存中，只要命中率高，它就能快速响应，毕竟是内存中的读写速度比数据库那种硬盘存写快上好多。</p></li><li><p>当前Redis已经成为主要的NoSQL工具，原因如下</p></li></ul><p><strong>响应快速</strong>：Redis的响应速度很快，每秒钟可以执行大约110000个写入操作，或是81000个读取操作，速度远超数据库。如果存入一些常用的数据，就可以有效地提高系统的效率。<br><strong>支持6种数据类型</strong>:它们是字符串，哈希结构，列表，集合，可排序集合和基数。<br><strong>操作都是原子性的</strong>:所有的操作都是原子性的，从而可以保证连个客户同时访问Redis服务器的时候，得到的是更新后的值。需要高并发的场合可以考虑使用redis的事务处理一些需要锁的业务。<br><strong>MultiUtility</strong>:Redis可以在像缓存，消息传递队列中使用，在应用程序像web应用会话，网站页面点击等短暂的数据中使用。</p><ul><li>先来 做一个小场景的讨论</li><li>现在要实现一个抢购的需求，那么为了满足高并发，肯定率先想到了使用Redis来进行存储货物的余量，但是怎么解决超卖的问题呢？</li></ul><ol><li>把该字段设置成unsigned</li><li>使用Redis中的散列，每次来一个请求就pop一个</li><li>用单例模式创建库存的对象</li><li>使用阻塞队列。</li></ol><ul><li>还没有进去学习，等到学习了之后希望能得到一个很有用的答案吧</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/17/Redis学习篇/cat.jpg&quot; alt=&quot;cat&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="JavaEE" scheme="http://yoursite.com/tags/JavaEE/"/>
    
      <category term="NoSQL" scheme="http://yoursite.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis学习篇</title>
    <link href="http://yoursite.com/2019/10/17/Mybatis%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/17/Mybatis学习篇/</id>
    <published>2019-10-17T08:34:38.000Z</published>
    <updated>2019-10-25T09:02:08.521Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/17/Mybatis学习篇/mybatis.jpg" alt="mybatis"></p><a id="more"></a><ul><li><p>Mybatis的前身是Apache的开源项目iBatis。是一个基于java的持久层框架。</p></li><li><p>优势：灵活，几乎可以替代jdbc。同时提供了接口编程，目前mybatis的数据访问层DAO是不需要实现类的，它只需要一个接口和xml。mybatis提供自动映射，动态sql，级联，缓存，注解，代码和sql分离等特性，还能对sql进行优化，使他取代Hibernate成为了java互联网中首选的持久层框架。</p></li><li><p>Hibernate：也是一个持久层的框架，那么区别在哪呢？都是提供把数据库中的表和pojo映射起来，就是关系映射（Object Relational Mapping）。简称ORM，那么Mybatis和Hibernate都是ORM框架，只是Hibernate的设计理念是完全面向pojo的，而Mybatis不是，Hibernate基本上是不需要再写sql语句就可以完成数据表到pojo的映射，可是Mybatis需要我们提供SQL去运行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.learn.chapter1.pojo.Role"</span> <span class="attr">table</span>=<span class="string">"t-role"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span><span class="attr">type</span>=<span class="string">"java.lang.Integer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rolelName"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name-</span>"<span class="attr">role_nane</span>"<span class="attr">1ength</span>=<span class="string">"60"</span><span class="attr">not-nul1</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">type</span>=<span class="string">"string"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"note"</span><span class="attr">1ength</span>=<span class="string">"512"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul><li><p>在移动互联网时代，Mybatis成了目前互联网java持久框架的首选，与Hibernate消除了Sql不同，Mybatis不屏蔽SQL，程序员就能自己定义SQL，无需Hibernate自动生成规则，这样能更加精确的定义SQL从而优化性能。更符合互联网高并发，大数据高响应的要求。</p></li><li><p>由于不用SQL，当多表关联超过三个的时候，通过Hibernate的级联，会造成太多性能的丢失，但是同样的Mybatis支持的工具也很有限，不想Hibernate那样有很多插件可以用。</p></li></ul><hr><h1 id="认识一下Mybatis的核心组件"><a href="#认识一下Mybatis的核心组件" class="headerlink" title="认识一下Mybatis的核心组件"></a>认识一下Mybatis的核心组件</h1><ul><li><strong>先看看外在呈现给我们的组件，回头再讨论原理</strong></li><li>SqlSessionFactoryBuilder(构造器):它会根据配置或者代码来生成SqlSessionFactory,采用的是分步构建的Builder模式</li><li>SqlSessionFactory:(工厂接口)：依靠他来生成SqlSession使用的是工厂模式</li><li>SqlSession(会话)：一个既可以发送SQL执行返回结果，也可以获取Mapper的接口。在现有的技术中一般我们会让其在业务逻辑代码中消失，而使用的是Mybatis提供的SQL Mapper接口编程技术。<br><img src="/2019/10/17/Mybatis学习篇/zujian.jpg" alt="组件"></li><li>无论是SqlSession还是映射器，都可以发送SQL到数据库中执行。<h2 id="SQLSessionFactory"><a href="#SQLSessionFactory" class="headerlink" title="SQLSessionFactory"></a>SQLSessionFactory</h2></li><li>使用Mybatis首先是使用配置或是代码去生产SqlSessionFactory,而Mybatis提供构造器SqlSessionFactoryBuilder。他提供了一个类org.apache.ibatis.session.Configuration作为引导，采用的是Builder模式，具体的分步则是在Configuration类里面完成的。</li><li>在Mybatis中，既可以通过读取配置的xml文件的形式生成SqlSessionFactory,也可以通过java代码的方式去生成SQLSessionFactory。</li></ul><p><strong>使用xml构建sqlSessionFactory</strong></p><ul><li><p>首先，在Mybatis中xml分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境，另一类是映射文件，它可以配置映射关系，sql参数，等信息，先看一份简单的基础配置文件，我们把它命名为mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3 //EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span><span class="comment">&lt;!--别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.learn.ssm.chapter.pojo.Role"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数据库环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enviroments</span> <span class="attr">default</span> =<span class="string">"development"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">enviroment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/ssm"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userneme"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name-</span>"<span class="attr">password</span>" <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">enviroment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">enviroments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/learn/ssm/chapter3/mapper/RoleMapper.xml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>我们来简单的看一下xml中各个标签的含义和作用。</p></li><li><ul><li><code>&lt;typeAlias&gt;</code>:元素定义了一个别名role。他是”com.learn.ssm.chapter.pojo.Role”这个的别名，有了这个东西，就可以用哪个role代替全限定名了</li></ul></li><li><ul><li><code>&lt;enviroment&gt;</code>:元素定义的是数据库，它里面的<transactionmanager>是配置事务管理器。这里采用的是Mybatis的JDBC管理器方式。然后采用<datasource></datasource>来配置数据库，其中“POOLED”代表采用Mybatis内部提供的连接池的方式。最后定义一些关于JDBC的属性信息。</transactionmanager></li></ul></li></ul><p><strong>SqlSession</strong></p><ul><li>在Mybatis中，SqlSession是其核心接口，Mybatis中有两个实现类，DefaultSqlSess和SqlSessionManager,DefaultSQLSession是单线程使用的，而SqlSession在多线程环境下使用，SqlSession的作用类似于有一个JDBC中的Connection对象，代表着一个连接资源的启用。具体而言，他的作用有三个</li><li><ul><li>获取Mapper接口</li></ul></li><li><ul><li>发送SQL给数据库。</li></ul></li><li><ul><li>控制数据库事务。</li></ul></li><li>注意，SqlSession只是一个门面接口，他有很多种方法，可以直接发送SQL，就好像是一家软件公司的商务人员，是一个门面，而实际干活的人是软件工程师。在Mybatis中，真正干活的是Excutor，我们会在底层看到他。这里也有很多事物处理的方法，如commit,或者是rollback。</li></ul><p><strong>映射器</strong></p><ul><li><p>映射器是Mybatis中最重要最复杂的组件，它由一个接口和对应的xml组成。可以配置以下内容</p></li><li><ul><li>描述映射规则</li></ul></li><li><ul><li>提供SQL语句，并可以配置SQL参数类型，返回类型，缓存刷新等等。</li></ul></li><li><ul><li>配置缓存。</li></ul></li><li><ul><li>提供动态SQL</li></ul></li><li><p>我们只需要提供一个pojo和一个接口，Mybatis会用动态代理技术使得接口可以运行起来，其实是生成了一个代理对象，代理对象会去处理相关的逻辑。</p></li><li><p><strong>xml实现映射器没啥好说的</strong></p></li><li><p>来看看注解实现映射器咋做的</p></li><li><p>只需要一个接口就可以实现Mybatis使用注解来注入SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.learn.ssm.chapter3.pojo.Role;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper2</span></span>&#123;</span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select id,name from t_role where id=#&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当xml和注解同时存在的时候，xml会覆盖掉注解，所以官方推荐的是xml方式。</p></li></ul><p><strong>SqlSession发送SQL</strong></p><ul><li>用Mapper接口发送SQL<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper=sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">Role role=roleMapper.getRole(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>生命周期是组建的重要问题，尤其是在多线程的环境中，比如互联网应用，socket请求等等。而Mybatis也常常用于多线程中，错误使用会造成严重的多线程并发问题。为了正确，我们要了解生命周期的问题。</li><li>SqlSessionFactoryBuilder的作用在于创建SqlSessionFactory,创建成功就失去了作用</li><li>SqlSessionFactory可以被认为是一个数据库连接池，他的作用是创建SqlSession接口对象。因为事实上Mybatis就是对数据库操作，所以可以认为SqlSession的生命周期就是等同于Mybatis的生命周期。</li><li>SqlSession，相当于一个Connection，你可以在一个事务里面执行多条SQL，然后通过他的commitrollback等方法，所以SqlSession应该存在于一个业务请求中，处理完整个请求之后，就应该关闭这条连接。</li><li>Mapper应该小于等于SQLSession。</li></ul><hr><h2 id="基础的就是上面的啦，接下来学习一下Mybatis的配置。我之前用的时候好像都没有配置来着。。。"><a href="#基础的就是上面的啦，接下来学习一下Mybatis的配置。我之前用的时候好像都没有配置来着。。。" class="headerlink" title="基础的就是上面的啦，接下来学习一下Mybatis的配置。我之前用的时候好像都没有配置来着。。。"></a>基础的就是上面的啦，接下来学习一下Mybatis的配置。我之前用的时候好像都没有配置来着。。。</h2><h1 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a>Mybatis配置</h1><ul><li>propert子元素：改写数据库链接的相关配置</li><li>使用properties是比较普遍的用法，创建一个jdbc.poperties文件放到classpath的路径下面。然后在Mybatis中通过<code>&lt;properties resource=&quot;jdbc.properties&quot;/&gt;</code>来引入文件。</li><li>实际的生成过程中可能会涉及到其中密码的加解密问题，这时候就要把密码解密，然后重置到我们的properties中。<h2 id="settings："><a href="#settings：" class="headerlink" title="settings："></a><strong>settings</strong>：</h2></li><li>Mybatis中最复杂的配置，它可以影响到Mybatis底层的运行，但是在大部分情况下默认就可以运行。只需要修改一些常用的规则就可以了，比如说自动映射，驼峰名映射，级联规则，是否启动缓存，执行器等等。<table><thead><tr><th align="center">配置项</th><th align="center">作用</th><th align="center">配置选项说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">casheEnabled</td><td align="center">该配置影响所有映射器中配置缓存的全局开关</td><td align="center">true/false</td><td align="center">true</td></tr><tr><td align="center">lazyLoadingEnabled</td><td align="center">延迟加载的全局开关，开了之后，所有的关联对象都会延迟加载，在特定的关联关系中可以通过设置fetchType来覆盖该项的开关状态</td><td align="center">true/false</td><td align="center">false</td></tr><tr><td align="center">agressiveLazyLoading</td><td align="center">当启用的时候，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载</td><td align="center">true/false</td><td align="center">3.4.1前true,后false</td></tr></tbody></table></li></ul><p>事实上还有很多配置项，但是全列出来背下来也不现实，用的时候再找吧。</p><h2 id="typeHandler类型转换器"><a href="#typeHandler类型转换器" class="headerlink" title="typeHandler类型转换器"></a>typeHandler类型转换器</h2><ul><li><p>负责转换javaType和jdbcType，其中jdbcType是用于定义数据库类型，而java是用来定义java类型的。一般不用配置就可以，Mybatis会自动探测到应该使用什么类型的TypeHandler进行处理，但是对于那些需要使用自定义枚举的场景，或者数据库使用特殊数据类型的场景，就是可以使用自定义的typehandler去处理类型之间的转换问题。</p></li><li><p>系统定义的typeHandler可以自己查表都有。</p></li><li><p>当需要自己创建typeHandler的时候，要实现接口：org.apache.ibatis.type.TypeHandler。</p></li><li><p>那么Mybatis系统的typeHandler是怎么实现的呢。第一就是继承了这个接口，然后实现一些抽象类和方法，完成存储过程啦注册过程啦等等。我们自己写typeHandler的时候一般是通过配置或者是扫描的方式进行注册的。</p></li><li><p>自定义typeHandler的时候，继承完接口之后，要去配置typeHandler,配置完了之后，系统才会去读取他</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">jdbcType</span>=<span class="string">"VERCHAR"</span> <span class="attr">javaType</span>=<span class="string">"String"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">handler</span>=<span class="string">"自己的类的地址"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>如果说，我们自定义的typeHandler很多呢，那要怎么办，不能一个一个配置吧，就要用到扫描配置的方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlertype</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.learn.sssm.chapter4.typeHandler"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlertype</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可是如果一但这样，大家就会发现一个问题，就是我没有办法指定我用的javatype和jdbcType了,不用担心，可以在自己写的类里面用注解的方式去处理他</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedTypes</span>(String.class)</span><br><span class="line"><span class="meta">@MappedjdbcTypes</span>(jdbcType.VARCHAR)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeHandler</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">string</span>&gt;</span>&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul><li><p>mybatis中，运行环境主要的作用是配置数据库信息，它可以配置多个数据库，一般而言一个就够了。他下面又分成了两个可配置的元素：事务管理器，数据源。在实际的工作中，大部分情况下会采用Spring对数据库的事务进行管理，这里我们聊一下Mybatis自身实现的类。</p></li><li><p><strong>transactionManager(事务管理器)</strong></p></li><li><p>他主要提供了两个实现类，和实现了一个接口，接口如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span></span>&#123;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据源环境</strong></p></li><li><p>按照我的理解，就是配置Mybatis用不用数据库池子的地方。</p><h2 id="引入映射器的方法"><a href="#引入映射器的方法" class="headerlink" title="引入映射器的方法"></a>引入映射器的方法</h2></li></ul><p><strong>文件路径引入映射器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span> =<span class="string">"文件路径"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>包名引入映射器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"包的名字"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>类注册引入映射器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"类的地方"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>用userMapper.xml引入映射器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"balabalbalba"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h1><ul><li>在Mybatis应用程序开发中，映射器的开发工作占全部工作的80%</li><li>话不多说，先来看看有什么<strong>元素</strong><table><thead><tr><th align="center">元素名称</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">select</td><td align="center">查询语句，最复杂，最常用的元素之一</td><td align="center">可以自定义参数</td></tr><tr><td align="center">sql</td><td align="center">允许定义一部分SQL，然后在各个地方引用他</td><td align="center">例如一张表列名，一次定义可以在多个sql语句中使用</td></tr><tr><td align="center">resultMap</td><td align="center">用来描述从数据库结果集中来加载对象，它是最复杂，最强大的元素</td><td align="center">他将提供映射规则</td></tr><tr><td align="center">cache</td><td align="center">给定命名空间的缓存配置</td><td align="center">-</td></tr><tr><td align="center">cache-ref</td><td align="center">其他命名空间的缓存配置的引用</td><td align="center">-</td></tr></tbody></table></li></ul><h2 id="映射器中，select元素代表SQL的select语句，用于查询。在SQL中，select语句是用的最多的语句，强大，复杂，先来看看select元素的配置"><a href="#映射器中，select元素代表SQL的select语句，用于查询。在SQL中，select语句是用的最多的语句，强大，复杂，先来看看select元素的配置" class="headerlink" title="映射器中，select元素代表SQL的select语句，用于查询。在SQL中，select语句是用的最多的语句，强大，复杂，先来看看select元素的配置"></a>映射器中，select元素代表SQL的select语句，用于查询。在SQL中，select语句是用的最多的语句，强大，复杂，先来看看select元素的配置</h2><table><thead><tr><th align="center">元素</th><th align="center">说明</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">他和Mapper的命名空间组合起来是唯一的，供Mybatis调用</td><td align="center">如果id和命名空间组合起来不唯一，那么将会报异常</td></tr><tr><td align="center">parameterType</td><td align="center">可以给出类的全命名，也可以给出别名，但是别名必须是Mybatis内部定义或是自定义的</td><td align="center">可以选择javaBean,Map等简单的参数类型传递给Sql</td></tr><tr><td align="center">resultType</td><td align="center">定义类的全路径，在允许自动匹配的情况下，结果集将通过javaBean的规范映射，或定义为int，double，float，map等参数，也可以使用别名但是要符合别名规范，且不能和resultmap同时使用</td><td align="center">常用的参数之一，比如统计条数的时候可以把它的值设置成int</td></tr><tr><td align="center">resultMap</td><td align="center">它是映射集的引用，将执行强大的映射功能，我们可以使用result和resultMap其中的一个，resultMap可以提供自定义映射规则的机会</td><td align="center">Mybatis最复杂的元素，可以配置映射规则，级联，typeHandler等</td></tr><tr><td align="center">flushCache</td><td align="center">它的作用是在调用SQL后，是否要求Mybatis清空之前查询本地缓存和二级缓存</td><td align="center">取值为布尔值，true/false.默认值是false</td></tr><tr><td align="center">useCache</td><td align="center">启动二级缓存的开关，是否要求Mybatis将此次结果缓存</td><td align="center">取值是布尔值，true/false默认值是true</td></tr><tr><td align="center">timeout</td><td align="center">设置超时参数，超时将会抛出异常单位是秒</td><td align="center">默认值是数据库厂商提供的jdbc默认值</td></tr><tr><td align="center">fetchSize</td><td align="center">获取记录的总条数规定</td><td align="center">默认值是数据库厂商提供的jdbc设置的条数</td></tr><tr><td align="center">statementType</td><td align="center">告诉jdbc的statement工作，取值是statement。prepared,callable</td><td align="center">默认值是prepared</td></tr><tr><td align="center">resultSetType</td><td align="center">这是对jdbc的resultSet接口而言，它的值包括forward_onlyscore(游标允许向前访问)，score_sensitive(双向滚动但是不及时更新，就是如果数据库里的值修改过，并不在resultSet中反映出来)Score_INsensitive(双向滚动，并及时的跟踪数据库的更新，以便更改resultSet中的数据)</td><td align="center">默认值是数据库厂商体统的jdbc驱动所设置的</td></tr><tr><td align="center">databaseId</td><td align="center">可以参考databaseIdprovider数据库厂商标识这一部分</td><td align="center">提供多种数据库的支持</td></tr><tr><td align="center">resultOrdered</td><td align="center">这个设置仅适用于嵌套结果select语句，如果为true，就是假设包含了嵌套结果集或是分组了，当返回一个主结果行时，就 不能引用前面结果集了，这就确保了在获取嵌套结果集时不至于导致内存不够用</td><td align="center">取值为布尔值，true/false</td></tr><tr><td align="center">resultSets</td><td align="center">适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔</td><td align="center">很少使用</td></tr></tbody></table><ul><li>在实际的工作中用的最多的是id，parameterType，resultType，resultMap，如果要用到缓存还要用到flushCache，useCache,其他都是不常用的功能。</li></ul><p><strong>自动映射和驼峰映射</strong></p><ul><li>默认情况下自动映射功能是开启的，使用它的好处是能有效减少大量的映射配置。从而减少工作量，在setting元素中有两个可以配置的选项，autoMappingBehavior和mapUnderscoreToCamelCase，她们是控制自动映射和驼峰映射的开关，一般而言自动映射会使用的多一点，因为可以通过SQL别名机制处理一些细节，比较灵活，驼峰映射比较严格，不是很常用</li><li>如果有一个pojo和编写好的SQL，SQL的列名和属性列名保持一致，可以用别名，想<code>select id role_name as rolename</code>那么他就会形成自动映射，不用别的配置就可以吧数据库中的相关列映射到pojo中，明显减少了工作量。</li><li>如果是驼峰的话，就不存在说能不一样的名字了，数据库中的名字必须严格和pojo对应。</li></ul><p><strong>传递多个参数</strong></p><ul><li>在Mybatis中允许map接口通过键值对传递多个参数，把接口方法定义为：<code>public List&lt;role&gt; findRolesByMap(Map&lt;String,Object&gt; parameterMap);</code>此时传递给映射器的是个map对象，使用他再sql中设置对应的参数</li><li><strong>使用注解传递</strong>：用map传递参数有个问题，就是可读性很差，因此Mybatis为开发者提供了一个注解@param,可以通过他去定义映射器的参数名称。使用它可以得到更好的可读性，接口方法就可以这么定义<code>public List&lt;role&gt; find(@Param(&quot;roleName&quot;) String rolename,@Param(&quot;note&quot;) String note);</code></li><li>还可以使用javaBean作为参数，然后查询。</li></ul><p><strong>分页参数RowBounds</strong></p><ul><li>Mybatis不仅支持分页，它还内置了一个专门处理分页的类，RowBounds,使用它十分简单，只要给接口增加一个RowBounds参数就行了，但是这个对于小数据量的支持会更好一些，如果是较大的数据查询，那么可以使用分页插件去处理。</li></ul><h2 id="相关元素"><a href="#相关元素" class="headerlink" title="相关元素"></a>相关元素</h2><p><strong>insert</strong></p><ul><li>语句:<code>insert into role(role_name,note) values(#{rolename},#{note})</code></li><li><strong>主键回填</strong></li><li>jdbc中的Statement对象在执行了插入的SQL之后，可以通过getGeneratedKeys方法获得数据库生成的主键，那么Mybatis也可以，在<code>&lt;insert useGeneratedKeys=&quot;true&quot;&gt;</code>这个开关来决定是否打开这个功能。如果选择这一项的值是打开，那么还要使用keyProperty或者keyColumn告诉系统把生成的主键放在哪个属性中如果存在多个主键，就用，把他们隔开</li></ul><p><strong>update和delete</strong></p><ul><li>用法相似，在相关的元素标签里面配置好SQL语句之后会执行返回一个整数代表修改或者删除的条数。</li></ul><p><strong>sql</strong></p><ul><li>作用就在于它可以定义个SQL的一部分，然后在select或者是insert等语句中反复使用他们。特别是那些字段比较多的表更是如此。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"roleCols"</span>&gt;</span></span><br><span class="line">id,role_name,note</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>特殊字符串的替换和处理</strong></p><ul><li>“$”:这种是拼接在sql语句上面的，不咋安全</li><li>“#”:这种是字符串的处理，更加安全，是把后面括号中的数据做了处理的额，可以防止sql注入攻击。</li></ul><h2 id="resultMap元素"><a href="#resultMap元素" class="headerlink" title="resultMap元素"></a>resultMap元素</h2><p><strong>元素的构成</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">idArg</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">case</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中constructor元素用于配置构造方法。一个pojo可能不存在没有参数的构造方法，可以使用constructor进行配置。假设有一个类RoleBean，不存在没有参数的构造方法，他的构造方法声明是这样的<code>public RoleBean(Integer id,String roleName)</code>,那么就要配置结果集了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">......</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"role_name"</span> <span class="attr">javaType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样子Mybatis就会用对应的构造方法来构造pojo了。<br>id元素表示哪个列是主键，允许多个主键，多个主键则称为联合主键。result是配置pojo到SQL列名的映射关系。result和idArg元素的属性如下表</p><table><thead><tr><th align="center">元素名称</th><th align="center">说明</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">property</td><td align="center">映射到列结果的字段或是属性。如果pojo的属性匹配的存在的且与给定的SQL列名是相同的，那么Mybatis就会映射到pojo上</td><td align="center">可以实用导航式的字段，比如访问一个学生对象Student，需要访问学生证的发放日期，可以写成selfcard.issueDate</td></tr><tr><td align="center">column</td><td align="center">对应的是SQL的列</td><td align="center">-</td></tr><tr><td align="center">javaType</td><td align="center">配置java类型</td><td align="center">可以是特定的类完全限定名或者Mybatis上下文的别名</td></tr><tr><td align="center">jdbcType</td><td align="center">配置数据库类型</td><td align="center">这是一个jdbc的类型，Mybatis已经做了限定，支持大部分常用的数据库类型</td></tr><tr><td align="center">typeHandler</td><td align="center">类型处理器</td><td align="center">允许用特定的处理器来覆盖Mybatis默认的处理器。这就要制定jdbcType和javaType相互转化的规则。</td></tr></tbody></table><p>除此之外还有一些级联设置的相关元素，稍候会详细讨论级联的相关知识<br><strong>使用map存储结果集</strong><br>一般而言，任何select语句都可以使用map存储 <code>&lt;select id=&quot;findColorByNote&quot; parameterType=&quot;String&quot; resultType=&quot;map&quot;&gt; select id,color,note from t_color where note like concat(&#39;%&#39;,#{note},&#39;%&#39;)&lt;/select&gt;</code><br>使用map原则上是可是匹配所有结果集，但是使用map接口就意味着可读性的下降，因为使用Map时要进一步了解map键值的构成和数据类型，所以这不是一种推荐的方式。更多的时候会推荐使用pojo的方式<br><strong>使用pojo存储结果集</strong><br>pojo是最长常用的方式。一方面可以使用自动映射，正如使用resultType一样，但是有的时候需要更为复杂的映射或者级联。这个时候还可以使用select的resultMap 属性配置映射集合，只是使用之前要配置resultmap。</p><h2 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h2><p>目的：实现数据的关联<br>好处：获取数据十分方便<br>坏处：当级联过多的时候，会增加系统的复杂度和耦合性，同时会降低系统的性能，所以当级联超过三层的时候就不应该使用级联了<br><strong>mybatis中的级联</strong><br>Mybatis中的级联分为三种</p><ul><li>鉴别器（discriminator）：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分</li><li>一对一（association）：比如学生证和学生就是一对一的级联关系，</li><li>一对多（collection）：班主任和学生就是一对多的级联<br>值得注意的是，Mybatis没有多对多的级联，因为太过复杂使用困难，而可以使用一对多来代替。<br>下面使用一个案例来说明<br><img src="/2019/10/17/Mybatis学习篇/jilian.jpg" alt="级联案例"><br>分析一下雇员的级联模型：</li><li>该模型是以雇员表为中心得。</li><li>雇员表和工牌表是一对一的关系</li><li>雇员表和员工任务表是一对多的级联关系</li><li>员工任务表和任务表是一对一的级联关系</li><li>每个雇员会有一个体检表，随着雇员表字段性别的取值不同会有不一样的关联表<br>建表代码过程略</li></ul><p><strong>建立pojo</strong></p><ol><li>男女体检表应该继承一个抽象的体检表。getter和setter略，各设置私有的体检属性。<br> 显然这个挂你应该是通过Mybatis的鉴别器去完成的</li><li>设计工牌表和任务表的pojo，工牌表以员工表为核心</li><li>接下来是雇员任务表，是雇员表和任务表的连接点。</li><li>最后是雇员表</li></ol><p><strong>配置映射文件</strong><br>配置映射文件是级联的核心内容，而对于Mapper的接口就不给出了。</p><pre><code class="xml"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"路径"</span> &gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTask"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"com.路径.pojo.task"</span>&gt;</span>        select id,title,context,note from t_task where id=#{id}    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/17/Mybatis学习篇/mybatis.jpg&quot; alt=&quot;mybatis&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaEE" scheme="http://yoursite.com/tags/JavaEE/"/>
    
      <category term="Mybatis" scheme="http://yoursite.com/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>深入nginx</title>
    <link href="http://yoursite.com/2019/10/16/%E6%B7%B1%E5%85%A5nginx/"/>
    <id>http://yoursite.com/2019/10/16/深入nginx/</id>
    <published>2019-10-16T13:37:36.000Z</published>
    <updated>2019-10-19T13:04:43.543Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/16/深入nginx/nginx.jpg" alt="nginx"></p><a id="more"></a><h1 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h1><ul><li>cacheloader</li><li>master</li><li>worker</li></ul><h1 id="反向代理（Reverse-Proxy）："><a href="#反向代理（Reverse-Proxy）：" class="headerlink" title="反向代理（Reverse Proxy）："></a>反向代理（Reverse Proxy）：</h1><pre><code>什么是反向代理呢？本人最直接的理解是 将外部的请求，通过 Nginx 软件转向内部请求当中，并响应相关请求。Nginx接收外部的连接请求，然后将请求转发给内部服务器，并将结果反馈请求客户端，此时代理服务器的表现为一个反向代理服务器。目的就是为了真实的内部服务器不能直接外部网络访问。代理服务器的前提条件是该服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境。</code></pre><p>反向代理简单配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">　　listen　　80;</span><br><span class="line"></span><br><span class="line">　　server_name　　localhost;</span><br><span class="line"></span><br><span class="line">　　client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">　　location / &#123;</span><br><span class="line"></span><br><span class="line">　　　　proxy_pass　　http://localhost:8080;</span><br><span class="line"></span><br><span class="line">　　　　proxy_set_header Host $host:$server:$server_port;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><ul><li><p>2台或以上的应用服务器时，根据相应规则将请求分发到某台服务器上处理。负载均衡配置一般都需要跟反向代理同时配置，通过反向代理跳转到负载均衡。（目前负载均衡的技术点：硬件层面有F5负载均衡器，网络层层面有LVS(Linux Virtual Server)，应用层层面就是nginx、Haproxy等。）</p></li><li><p>常用的 Nginx 负载均衡策略（RR（默认）、轮询、ip_hash，fair、url_hash）：</p></li><li><p>RR:一台一台轮着来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line"></span><br><span class="line">　　server 192.168.1.22:8080;</span><br><span class="line">　　server 192.168.1.23:8080;</span><br><span class="line">&#125;</span><br><span class="line">server　　&#123;　</span><br><span class="line"></span><br><span class="line">　　listen　　80;</span><br><span class="line"></span><br><span class="line">　　server_name localhost;</span><br><span class="line"></span><br><span class="line">　　client_max_size 1024;</span><br><span class="line"></span><br><span class="line">　　location / &#123;</span><br><span class="line"></span><br><span class="line">　　　　proxy_pass http://test;</span><br><span class="line"></span><br><span class="line">　　　　proxy_set header  Host  $host:$server:$server_post;</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>轮询策略：<br>　　RR （默认）:upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。<br>　　weight(按权重轮询):指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况而设定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">   server 192.168.1.22 weight = 6； ---将 60% 的请求分配到该服务器中 </span><br><span class="line">   server 192.168.1.23 weight = 4； ---将 40% 的请求分配到该服务器中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash方式：<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。配置只需要在upstream中加入”ip_hash;”即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">　　ip_hash;</span><br><span class="line">　　server 192.168.1.22:8080;</span><br><span class="line">　　server 192.168.1.23 8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>far方式（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。与weight分配策略类似。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">　　far;</span><br><span class="line">　　server 192.168.1.22:8080;</span><br><span class="line">　　server 192.168.1.23 8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>url_hash（第三方）<br> 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">　hash $request_url;</span><br><span class="line">　　hash_method crc32;</span><br><span class="line"></span><br><span class="line">　　server 192.168.1.22:8080;</span><br><span class="line">　　server 192.168.1.23 8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/16/深入nginx/nginx.jpg&quot; alt=&quot;nginx&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习篇</title>
    <link href="http://yoursite.com/2019/10/16/Spring%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/16/Spring学习篇/</id>
    <published>2019-10-16T08:00:23.000Z</published>
    <updated>2019-10-17T09:36:33.683Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/16/Spring学习篇/spring.jpg" alt="spring"></p><a id="more"></a><h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><ul><li><p>POJO编程模型：plain Old java Objects 就是简单的java对象,旨在简化java应用程序的编码，测试以及部署等阶段</p></li><li><p>EJB：EJB技术最先于1997年提出。他提供了一种与运行时平台相结合的分布式业务组件，该运行时平台提供了执行Ejb组件所需的所有中间件服务。在当时，Ejb是J2ee规范中的主要规范。但是他有很大的缺陷，1. 为了实现开发人员编写的代码和组件接口之间实现紧耦合，要实现很多组件的接口写一个应用程序类2. 可测试性是原来Ejb编程模型最大的问题之一。3.将开发人员转向了过程程序设计风格，随着时间的推移，EJB也在不断地改进</p></li><li><p>POJO模型的优点：写应用程序类那是非常简单。在一个，好测试，Junit在自己的IDE中就可以测试，</p></li><li><p>轻量级容器：可以向应用程序提供一些基本的服务来保证应用程序的正常运行，如生命周期管理啊依赖解析什么的，当然要是能提供一些事务管理或是安全性的功能的话就更好了。而一个轻量级的容器，包括所有的上面说道的功能而不需要为了依赖这些api而编写应用程序代码。没有侵入的特性，启动很快。在企业级的java世界中，SpringApplicationFramework是最著名的轻量级容器之一。</p></li><li><p>控制反转（IOC）：容器和组件能提供的最大的好处就是可以插拔的体系结构，容器的工作就是创建这些组件以及所依赖的服务，并将这些组件装配到一起。在组件类中，不需要新的操作符来实例化依赖组件，而是在运行时由容器实例将依赖组件注入组件，因此，对依赖项的控制由组件转到容器。就是把控制权交给了容器，我们把这种模式叫做控制反转（IOC），控制反转被认为是任何容器都 需要提供的基本功能之一，他主要有两种形式：依赖查找和依赖注入。 依赖查找中，容器向其管理的组件提供了回调方法，依赖注入中，组件提供了合适的额构造函数，或者Setter方法，以便容器可以注入依赖组件<br>最重要：解耦</p></li><li><p>Aop：面向切面IoC的目标是为了管理对象，通过依赖注入达到了对象之间的解耦，但是很多情况是面向对象没有办法处理的，比如生产部门的订单，生产部门，财务部门，三者是对象昂，但是财务部门发现预算超支，那么就不是财务部门一个的事了，还会影响到前面生产部门所做的审批，要把他们作废。我们把预算超支这个条件，叫做切面。面向切面的编程来去管理在切面上某些对象之间的协作。<br>  通常用来做数据库的事务编程，用异常作为消息，默认情况下接到了异常消息就会把数据库事务回滚，从而保证数据的一致性。</p></li><li><p>Setter注入：当一个对象在实例化之后就会马上调用setter方法，该注入在组件的创建或初始化阶段发生，并且在处理业务方法调用之前完成，最大的优点是运行时可以对组件进行重新配置，组件的依赖项可以在运行时更改，缺点：并不是所有的所需要的依赖项都可以在使用前被注入，从而使组件处于一种版配置的状态</p></li><li><p>构造函数注入：使用构造函数的参数来表达依赖项，可以一次使容器中被管理的各个组件都处于同样的状态，并且在创建之后可以马上使用。代码量也会小一点。但是无法再对组件进行配置。</p></li></ul><h1 id="Spring-依赖注入"><a href="#Spring-依赖注入" class="headerlink" title="Spring 依赖注入"></a>Spring 依赖注入</h1><h2 id="SpringIOC容器"><a href="#SpringIOC容器" class="headerlink" title="SpringIOC容器"></a>SpringIOC容器</h2><p>SpringApplicationFramework的核心是他的IOC容器，介个容器的工作职责包括对应用程序的对象进行实例化、初始化、装配以及在对象的整个生命周期中提供其他的Spring功能。<br><strong>配置元数据</strong><br>啥是元数据：就是扫描bean包的那个xml就叫元数据，就是告诉容器去哪里找到我的组件，元数据有两种形式一种就是xml的那种另外就是注解的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> AccountsDao accountdao;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.accountdao=accountDao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoInMemoryImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种就是使用了java注解的方式定义Bean，@Service和@Repository被用来定义两个bean，而实际上他们又是注解@Component的具体形式。此外@Autowired通常用来指定在运行时被Spring容器所注入的Bean依赖</p><p><strong>配置和使用容器</strong><br>Spring容器也是一个java对象，在某些特定的时间点被创建，并允许管理应用程序的其他部分，可以使用两种方法来实例化Spring容器。在独立的应用程序中，可是用编程的方法，而在web应用程序中，使用声明方法则是更好的选择</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><strong>setter</strong></p><ul><li>setter注入是在Bean实例创建完毕之后执行，通过调用与bean的配置元数据中定义的所有属性相对应的Setter方法注入这些属性。此外还可以注入其他Bean依赖项和简单值，比如字符串，类，枚举等</li><li>可以使用<property>的ref特性指定对其他bean的引用。</property></li><li>还可以使用<property>的value特性注入其他依赖值，如int，boolean等等</property></li><li>Spring还允许注入Collection或是map值</li></ul><p><strong>构造函数注入</strong></p><ul><li>构造函数注入依赖的一个缺点是无法处理循环依赖，假如有两个Bean ：a,b而这两个Bean通过各自的构造函数互相为依赖项，那么Spring容器就无法实例化这两个Bean，有点儿像死锁的感觉</li></ul><p><strong>依赖的解析过程</strong></p><ul><li>Spring容器的启动过程大致可以分成连个主要的阶段，第一个阶段，容器处理配置元数据，并建立元数据中存在的Bean定义，在该过程中还会对这些Bean定义进行验证。但是在这个阶段中，Bean还没有被创建，相关的属性也没有被注入。  第二个阶段，首先完成Bean的创建，然后完成依赖的注入。实际上，不是所有的Bean都被创建，有关Bean的作用域的问题，我们以后再讨论。<h2 id="Spring管理的Bean"><a href="#Spring管理的Bean" class="headerlink" title="Spring管理的Bean"></a>Spring管理的Bean</h2>被Spring创建和管理的对象被称为Bean。这些对象都是pojo，但是却在Spring中进行管理。</li></ul><p><strong>命名Bean</strong></p><ul><li>通过名称进行区分，每个Bean至少有一个名称，如果开发人员没有为他命名，那么Spring容器将会为他分配一个内部名称。通过这个名称，可以从其他Bean定义中或者用显式查找从应用程序代码中应用Bean在基于xml的配置中，使用id特性将一个名称分给一个Bean，在相同的xml中不能复制同一个名称。</li></ul><p><strong>Bean实例化方法</strong></p><ul><li>创建Bean最常用的方法是调用相关类中的一个可用的构造函数，就是实例化这个类</li><li>第二种方法是调用可用的静态方法或实例工厂方法</li><li>使用spring自带的FactoryBean接口。</li></ul><p><strong>Bean的作用域</strong><br>由spring容器创造的Bean的生存周期叫做Bean的作用域。</p><ul><li>SpringApplicationframework支持的内置作用域<table><thead><tr><th align="center">作用域名称</th><th align="center">作用域定义</th></tr></thead><tbody><tr><td align="center">singleton</td><td align="center">从Bean定义中仅创建一个实例。这是默认的作用域</td></tr><tr><td align="center">prototype</td><td align="center">每一次对Bean定义的访问，都会创建一个新的Bean实例，类似于java中的new关键字</td></tr><tr><td align="center">request</td><td align="center">整个web请求过程中使用相同的Bean实例。每个web请求都会创建一个新的Bean实例，仅适用于支持web的ApplicationContext</td></tr><tr><td align="center">session</td><td align="center">针对一个特定的HTTP会话使用相同的Bean实例。每一个Web请求都会创建一个新的Bean实例。仅适用支持Web的ApplicationContexts</td></tr></tbody></table></li></ul><p><strong>延迟初始化</strong><br>    默认的情况下，Spring容器在启动阶段创建Bean，该过程被称为预先Bean初始化，优点是可以尽早的发现配置错误。但是另一方面，如果存在大量的Bean定义，那么初始化就会占用很长的时间，而一些Bean可能只会在特定的场景中才会用到，预先初始化就会造成不必要的堆内存消耗。<br>    Spring支持延迟Bean的初始化。<br>    如果开发人员将Bean设置称为延迟创建，呢么Bean就会只有在被使用到的时候才会创建。<br>    在基于XML的配置中，可在<bean>元素中使用lazy-init属性把Bean定义为延迟。（ps:我感觉就是懒汉模式）</bean></p><pre><code>优点：加快了容器启动时间，并且占用较少的内存量。</code></pre><hr><p><em>接下来进入正题</em></p><h1 id="使用SpringMvc构建web应用程序"><a href="#使用SpringMvc构建web应用程序" class="headerlink" title="使用SpringMvc构建web应用程序"></a>使用SpringMvc构建web应用程序</h1><h2 id="SpringMvc的功能和优点"><a href="#SpringMvc的功能和优点" class="headerlink" title="SpringMvc的功能和优点"></a>SpringMvc的功能和优点</h2><p><strong>什么是SpringMvc</strong></p><ul><li>是一个分层的javaWeb开发框架。<br><img src="/2019/10/16/Spring学习篇/mvc.png" alt="mvc"></li></ul><p><strong>好处</strong></p><ul><li>框架突出了http协议中的请求响应的特性</li><li>因为SpringMvc是Spring的一个子项目，所以说它完全集成了Spring的核心功能，比如依赖注入的机制。你可以非常容易的为控制器配置和使用基于注解的定义。</li><li>SpringMvc提供了一种绑定机制。通过该机制可以从用户请求中提取数据。然后将数据转换成预定义的数据格式。最后映射到一个模型类，从而创建一个对象。</li><li>SpringMvc是视图不可知（view-agnostic)的，对于视图层，不一定要使用jsp</li></ul><p><strong>使用DispatcherServlet</strong></p><ul><li>可以说SpringMvc的核心就是dispatcherServlet,它是主要的Servlet，负责处理所有的请求。并将请求调度到合适的通道。SpringMvc采用了 一种前端控制器模式（front controller pattern）,该模式提供了一个入口点来处理web应用程序的所有请求。具体的工作细节，可以参考那一篇  SpringMvc学习总结</li></ul><p><strong>定义servlet</strong></p><ul><li>DispatcherServlet的定义包含在web.xml文件中<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">org.springframework.web.servlet.DispatcherServlet</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.mvc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/16/Spring学习篇/spring.jpg&quot; alt=&quot;spring&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>vim学习篇</title>
    <link href="http://yoursite.com/2019/10/16/vim%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/16/vim学习篇/</id>
    <published>2019-10-16T03:49:56.000Z</published>
    <updated>2019-10-16T07:38:50.273Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/16/vim学习篇/vim.jpg" alt="vim-linux文本程序"></p><a id="more"></a><p>在Linux上干活，没有个顺手的编辑器怎么行，之前对vim的了解都浅的发指，这次准备深耕一下。<br>vim是最早的一种交互式的可视化文本编辑器，功能很强大</p><h2 id="用vim创建和编辑文本文件"><a href="#用vim创建和编辑文本文件" class="headerlink" title="用vim创建和编辑文本文件"></a>用vim创建和编辑文本文件</h2><p><strong>启动vim</strong></p><ul><li>使用vim filename 可以创建一个名字是filename的文件。</li><li>vi也可以</li></ul><p><strong>Esc</strong></p><ul><li>进入命令模式</li></ul><p><strong>：</strong></p><ul><li>最后一行模式，光标将始终处于屏幕底部。当按下return后才会回到他在文本中的位置</li></ul><p><strong>i</strong></p><ul><li>输入模式，输入文本之前要按</li></ul><p><strong>移动光标</strong></p><ul><li>删除，插入和校准都需要在屏幕上移动光标。当vim处于命令模式时间，可以使用return，空格，和方向键，没有方向键的也可使用h,j,k,l</li></ul><p><strong>删除</strong></p><ul><li>删除字符：x</li><li>删除字：dw</li><li>删除行：dd</li></ul><p><strong>撤销操作</strong></p><ul><li>命令行输入：u</li><li>重做当撤销了某条命令后又想重新执行该命令：redo</li></ul><p><strong>添加文本</strong></p><ul><li>向已有文本内容的文本中插入新文本的步骤是：首先将光标移动到新文本位置之后的字符上，然后输入i,使vim处于输入模式</li><li>光标移动到位，使用a进行追加内容</li></ul><p><strong>结束</strong></p><ul><li>在编辑的过程中，vim将编辑的文本放到工作缓冲区中，当结束编辑时，必须将工作缓冲区的内容写入磁盘</li><li>在命令模式下输入ZZ（大写），将新写入的内容写到磁盘中，这样才能保存已经编辑的文本。</li><li>不想保存：q！<h2 id="vim的操作模式有几种："><a href="#vim的操作模式有几种：" class="headerlink" title="vim的操作模式有几种："></a>vim的操作模式有几种：</h2></li><li>vim命令模式 按下esc而没有按：的那种模式</li><li>vim输入模式 按下i的模式</li><li>最后一行模式 按下：的模式</li><li>最后一行模式和命令模式的不同点在于：光标位置不同，命令模式中结束命令不必按return<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2></li></ul><p><strong>状态行</strong></p><ul><li>会在底部显示状态信息</li></ul><p><strong>重绘屏幕</strong></p><ul><li>命令模式下 CONTROL+L<br>有的时候乱了就用这个扭曲啊啥的</li></ul><p><strong>代字符</strong></p><ul><li>~ :一个波浪线</li><li>到达文件的末尾的时候会显示一个代字符</li></ul><p><strong>行长度和文件大小</strong></p><ul><li>vim对两个换行符中间的长度没有限制，它仅售可用内存的影响</li></ul><p><strong>窗口</strong></p><ul><li>vim允许打开，关闭，和隐藏多个窗口，每个窗口可以分别用于编辑不同的文件。多数窗口命令由CONTROL+W和另一个字母组成。</li><li>CONTROL+W s:打开另一个窗口分割屏幕来编辑同一个文件</li><li>CONTROL+W n:打开一个窗口来编辑一个空文件；</li><li>CONTROL+W w:将光标在窗口中移动</li><li>CONTROL+W q:关闭或退出窗口</li></ul><p><strong>崩溃后的文本回复</strong></p><ul><li>vim会把操作过得交换文件零食存储起来，如果系统突然崩溃，那么可以根据这些临时文件对文件进行恢复。</li><li>使用vim -r来确认交换文件是否存在</li></ul><p><strong>光标移动</strong></p><ul><li>H键将光标定位到屏幕顶部一行的最左端；M键将光标定位到屏幕的中间一行；L键将光标定位到底部一行。</li></ul><p><strong>替换文本</strong></p><ul><li>命令r</li></ul><p><strong>查找替换</strong></p><ul><li>查找：f:在当前行查找指定字符并将光标移动到他下一次出现的位置</li><li>t/T：与查找命令具有相同的用法。</li><li>查找字符串：按/键输入要查找的字符串。</li><li>按n键找下一个</li><li>^:如/^the:将搜索以the开始的下一行</li><li>$:行尾匹配符如/end$以end结束的句子</li><li>.：任意字符如：l..t可以是loit,loot等等中间的两个字符随便</li><li>/<em>:0次或多次出现，这个字符是一个修饰符，如/dis\</em>m,匹配di+0个或多个s的字符串</li><li>[]:将两个或者多个字符括起来的方括号，与方括号内的单个字符匹配。如/dis[ck],找disc或disk</li></ul><hr><p>暂且留住，日后用到的时候继续补充。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/16/vim学习篇/vim.jpg&quot; alt=&quot;vim-linux文本程序&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://yoursite.com/2019/10/15/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/15/Markdown常用语法/</id>
    <published>2019-10-15T09:51:34.000Z</published>
    <updated>2019-10-17T11:09:35.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/15/Markdown常用语法/kk.jpg" alt="kk"><a id="more"></a><br>语法代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br><span class="line"><span class="section">###### 这是六级标题</span></span><br><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">***这是斜体加粗的文字**</span>*</span><br><span class="line">~~这是加删除线的文字~~</span><br><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br><span class="line">---  分割线</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span>  分割线</span><br><span class="line"><span class="strong">*****</span></span><br><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可加可不加</span><br><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line">列表嵌套</span><br><span class="line">上一级和下一级之间敲三个空格即可</span><br><span class="line"><span class="bullet">* </span>表格</span><br><span class="line"><span class="bullet">* </span>表格</span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line"><span class="bullet">- </span>有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="—-分割线"><a href="#—-分割线" class="headerlink" title="—  分割线"></a>—  分割线</h2><p>***  分割线</p><hr><p><a href="超链接地址" title="超链接title">超链接名</a><br>title可加可不加</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p>1.列表内容<br>2.列表内容<br>3.列表内容<br>列表嵌套<br>上一级和下一级之间敲三个空格即可</p><ul><li>表格<table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/15/Markdown常用语法/kk.jpg&quot; alt=&quot;kk&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>linux学习篇</title>
    <link href="http://yoursite.com/2019/10/15/linux%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <id>http://yoursite.com/2019/10/15/linux学习篇/</id>
    <published>2019-10-15T08:56:05.000Z</published>
    <updated>2019-10-16T03:31:05.755Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/15/linux学习篇/linux.jpg" alt="linux"></p><a id="more"></a><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试"><a href="#首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试" class="headerlink" title="首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试"></a>首先，要准备一个linux的系统，不管是虚拟机，或者是云端的服务器，或者是win10商店中的Ubuntu，都可以试一试</h2><p>win10 下开启 控制面板-&gt;程序-&gt;启用或关闭windows功能-&gt;适用于Linux的windows子系统-&gt;重启。<br>应用商店里搜索：linux，下载Ubuntu启动就可以了。<br><img src="/2019/10/15/linux学习篇/ubuntu.png" alt="ubuntu"><br>做一个简简单单的小测试吧，使用ps命令查看自己的控制台是哪个程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   34 tty1     00:00:00 bash</span><br><span class="line">   49 tty1     00:00:00 ps</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure><p><strong>我们都知道文档是很重要的，那么Linux系统早期发布的系统是通常没有纸质版的参考手册，可是联机文档一直是他的强项之一，怎么找到和使用之呢？</strong></p><ul><li>大多数的GUN实用程序都有-help命令显示帮助信息</li><li>使用man 如man man,man git,空格翻页，man password 将找到password在man页中对应的内容</li><li>appropos 使用关键字和appropos 可以查找某个任务的命令，appropos会在man页的顶行信息中找到搜索关键字，whatis 可以准确搜索，结果会是完全匹配的</li><li>info程序：显示使用程序的说明文档，空格翻页，/+字符串进行查找</li></ul><p><strong>linux更改密码</strong></p><ul><li>在命令行中输入passwd即可修改密码，系统会先询问你旧密码，之后输入新密码</li></ul><h1 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h1><h2 id="关于shell"><a href="#关于shell" class="headerlink" title="关于shell"></a>关于shell</h2><p><strong>shell的特殊字符</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; ; | * ? ' " ` [] () $ &lt;&gt; &#123;&#125; # / \ ! ~</span><br></pre></td></tr></table></figure><h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><p><strong>ls</strong></p><ul><li>显示文件名和目录名</li><li>可以执行 info ls 来看文档</li></ul><p><strong>cat</strong></p><ul><li>显示文本文件的内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ vi gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ ls</span><br><span class="line">gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ cat gss</span><br><span class="line">各位小伙伴们大家好呀！</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p><strong>rm</strong></p><ul><li>删除文件</li><li>跟文件名在后面会直接删除，</li><li>rm -i file 这种命令会有提示询问是否删除</li></ul><p><strong>less,more</strong></p><ul><li>分页程序，当文件的内容超过一页的时候，使用之</li><li>less filename</li><li>more filename</li></ul><p><strong>hostname</strong></p><ul><li>显示正在使用的主机名字<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ hostname</span><br><span class="line">DESKTOP-4H90EP2</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><strong>cp</strong></p><ul><li>复制文件，对任何文件进行复制，包括文本文件或是可执行文件（二进制文件）</li><li>cp source-file(源文件) destinnation-file（目标文件名）</li><li>如果cp的目标文件是一个已经存在的文件，那么cp会重写这个文件，没有提示，所以要慎重的使用cp,同理使用 -i后缀可以有提示</li></ul><p><strong>mv</strong></p><ul><li>更改文件名</li><li>mv afilename newfilename</li><li>mv 也会覆盖文件，建议加-i</li></ul><p><strong>lpr</strong></p><ul><li>把文件放到打印序列中按行打印</li><li>lpr -P machenname filename 选择打印机打印file</li><li>lpq可以查看打印队列中的作业</li><li>lprm 88：把序号是88的作业删除</li></ul><p><strong>grep</strong></p><ul><li>查找字符串</li><li>grep ‘关键字’ filename</li><li>不止可以在文件中找</li></ul><p><strong>head</strong></p><ul><li>默认显示文件的前10行信息</li><li>month -数字 filename:显示文件的前几行</li><li>还可以按照块儿或者字符显示</li></ul><p><strong>tail</strong></p><ul><li>显示文件的尾部</li><li>与head类似</li><li>可以用这个监控逐渐增长的某个文件的内容</li></ul><p><strong>sort</strong></p><ul><li>将文件内容按行排序之后输出来，但是不改变文件内容</li><li>-u:使得排序列表的每一行都唯一</li><li>-n:对一列数排序</li></ul><p><strong>uniq</strong></p><ul><li>用来显示文件内容，对于重复的行只显示一行，不会改变源文件的内容</li><li>sort+uniq等同于带u的sort</li></ul><p><strong>diff</strong></p><ul><li>比较两个文件显示两者所有的不同之处</li><li>带上-u会说明比较得是哪两个文件</li><li>查看更多信息可以info</li></ul><p><strong>file</strong></p><ul><li>获得Linux系统中任何文件的内容信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ file gss</span><br><span class="line">gss: UTF-8 Unicode text</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><h2 id="管道：实现进程间的通信"><a href="#管道：实现进程间的通信" class="headerlink" title="管道：实现进程间的通信"></a>管道：实现进程间的通信</h2><ul><li>表示：|</li><li>把一个进程的结果当成另一个进程的输入传递进去</li><li>如sort months | head -4  把拍好序的month的前四行输出</li><li>管道是linux不可缺少的功能<h2 id="重要的四个程序"><a href="#重要的四个程序" class="headerlink" title="重要的四个程序"></a>重要的四个程序</h2></li></ul><p><strong>echo</strong></p><ul><li><p>显示文本</p></li><li><p>echo把命令行中除了echo的所有东西复制到屏幕上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span> hi</span><br><span class="line">hi</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span> i love linux</span><br><span class="line">i love linux</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">echo</span> 复读机</span><br><span class="line">复读机</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li><li><p>通过echo可以把输出重定向到文件中，如echo ‘hello’ &gt; gss,就是把echo放到gss中</p></li></ul><p><strong>date</strong></p><ul><li><p>显示当前的日期和时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ date</span><br><span class="line">Tue Oct 15 20:20:20 CST 2019</span><br></pre></td></tr></table></figure></li><li><p>跟一些参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%A %B %d"</span></span><br><span class="line">Tuesday October 15</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%A %b %d"</span></span><br><span class="line">Tuesday Oct 15</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%A %b %D"</span></span><br><span class="line">Tuesday Oct 10/15/19</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ date +<span class="string">"%a %b %D"</span></span><br><span class="line">Tue Oct 10/15/19</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p><strong>script</strong></p><ul><li>记录shell会话信息</li><li>键入script,就开始记录，键入exit结束记录</li><li>可以记下来命令行之间的交互内容，如<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ script</span><br><span class="line">Script started, file is typescript</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">"root"</span>), use <span class="string">"sudo &lt;command&gt;"</span>.</span><br><span class="line">See <span class="string">"man sudo_root"</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">gss@DESKTOP-4H90EP2:~$ whoami</span><br><span class="line">gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">Script <span class="keyword">done</span>, file is typescript</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ cat typescript</span><br><span class="line">Script started on 2019-10-15 20:33:27+0800</span><br><span class="line">To run a <span class="built_in">command</span> as administrator (user <span class="string">"root"</span>), use <span class="string">"sudo &lt;command&gt;"</span>.</span><br><span class="line">See <span class="string">"man sudo_root"</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">gss@DESKTOP-4H90EP2:~$ whoami</span><br><span class="line">gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">Script <span class="keyword">done</span> on 2019-10-15 20:33:54+0800</span><br></pre></td></tr></table></figure></li></ul><p><strong>todos</strong></p><ul><li>把linux中的文本文件转换成Windows格式</li><li>todos gss.txt<br>##压缩和归档文件</li></ul><p><strong>bzip2</strong></p><ul><li>这个软件适合重复信息很多的图片，如文本和图像，压缩效果很好</li><li>但是使用的时候，会删掉原来的文件，可以使用 bzip -k filename 来保留源文件</li><li>bzip2 filename   会自动生成一个filename.bz2压缩包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ bzip2 gss2</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ ls</span><br><span class="line">gss  gss2.bz2  sfile  typescript</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p><strong>bunzip2和bzcat</strong></p><ul><li>用来解压文件</li><li>同样的用法，注意也会删掉压缩包</li></ul><p><strong>tar</strong></p><ul><li>打包和解包文件</li><li>打包：tar -cvf afile bfile cfile</li><li>解包：tar -xvf xxx.tar</li><li>使用man可以查看更多的内容<h2 id="定位命令"><a href="#定位命令" class="headerlink" title="定位命令"></a>定位命令</h2></li></ul><p><strong>which和whereis</strong></p><ul><li><p>定位实用程序</p></li><li><p>一个概念：搜索路径：输入一个linux命令之后，shell将在一组目录下查找具有该名称的程序，并运行找到的第一个，这组目录被叫做搜索路径，可以更改，日后再讲（猜测是环境变量类似的），如果不改变，就只在标准路径下搜索，然后停止。</p></li><li><p>which：通过显示程序的完整路径来帮助查找之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">which</span> tar</span><br><span class="line">/bin/tar</span><br></pre></td></tr></table></figure></li><li><p>whereis:在标准路径下搜索与实用程序相关的文件</p></li><li><p>这俩只能报告在磁盘上的程序路劲，无法找到内置命令，要是想要确认命令是不是内置命令，可以使用type 如：type echo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">type</span> locate</span><br><span class="line">locate is hashed (/usr/bin/locate)</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">type</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>slocate/locate</strong></p><ul><li>搜索文件</li><li>用于在本地文件系统上搜索文件</li><li>locate file<h2 id="获取用户和系统信息"><a href="#获取用户和系统信息" class="headerlink" title="获取用户和系统信息"></a>获取用户和系统信息</h2>怎么显示正在使用系统的用户，以及显示他们在做什么，和系统如何运行的信息</li></ul><p><strong>who</strong></p><ul><li>最老的实用程序，给出登录到本地系统的用户列表，每个用户在使用的设备，和每个用户登录的时间。</li></ul><p><strong>w</strong></p><ul><li>当希望和本地系统上的其他用户通信的时候，会很有用，比who的功能更加强大，<h2 id="与其他用户进行通信"><a href="#与其他用户进行通信" class="headerlink" title="与其他用户进行通信"></a>与其他用户进行通信</h2></li></ul><p><strong>write</strong> </p><ul><li>给另一个登录用户发送消息</li></ul><p><strong>mesg</strong></p><ul><li>拒绝或接受消息</li></ul><h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><p>文件系统是一组数据结构，驻留在磁盘中用来组织和管理文件的目录</p><h2 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h2><p>linux文件系统也被称为树，由一系列相互关联的文件组成，树状结构方便了文件的组织与查找。在标准linux系统上，每个用户都有自己的一个目录，在这个目录下，用户可以添加多个子目录来尽可能满足自己的需求。</p><h2 id="文件和文件名"><a href="#文件和文件名" class="headerlink" title="文件和文件名"></a>文件和文件名</h2><p>使用 ls -a 可以显示隐藏文件（以.开始的文件名）一般启动文件的文件名都是以.开始的<br><strong>工作目录</strong></p><ul><li>pwd:显示当前的工作目录</li><li>主目录：/home/具体用户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/gss</span><br></pre></td></tr></table></figure></li></ul><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p><strong>mkdir</strong></p><ul><li>创建目录</li><li>可以使用mkdir + 目录名</li><li>也可以使用mkdir+绝对路径</li></ul><p><strong>cd</strong></p><ul><li>更改工作目录</li><li>mkdir在创建目录的时候，会自动创建两个目录.和..这两个，.代表该目录本身。..代表上一级</li></ul><p><strong>rmdir</strong></p><ul><li>用来删除目录</li><li>注意，要是想要删除的文件目录中含有文件，那么只有在删掉了其中的文件之后才能删掉这个目录</li><li>使用rm -r可以递归的删除文件目录和文件目录的子目录</li><li>但是务必要慎重使用rm -r</li></ul><p><strong>mv/cp</strong></p><ul><li>移动和复制文件</li><li>上一个标题中，我们有提到过mv可以重命名，事实上，移动文件也是使用这个命令</li><li>mv filelist directory:把一组文件（列表显示）移动到一个目录中</li><li>同理可以移动目录，只要把文件列表改成目录列表就行了<h2 id="重要的标准目录和文件"><a href="#重要的标准目录和文件" class="headerlink" title="重要的标准目录和文件"></a>重要的标准目录和文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:/$ ls</span><br><span class="line">bin   dev  home  lib    media  opt   root  sbin  srv  tmp  var</span><br><span class="line">boot  etc  init  lib64  mnt    proc  run   snap  sys  usr</span><br><span class="line">gss@DESKTOP-4H90EP2:/$</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">目录名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="left">/</td><td align="center">根目录</td></tr><tr><td align="left">/bin</td><td align="center">基本命令的二进制文件</td></tr><tr><td align="left">/boot</td><td align="center">引导加载程序的静态文件</td></tr><tr><td align="left">/dev</td><td align="center">设备文件</td></tr><tr><td align="left">/etc</td><td align="center">本地计算机系统配置文件</td></tr><tr><td align="left">/etc/opt</td><td align="center">包含/opt目录下插件软件的配置文件</td></tr><tr><td align="left">/home</td><td align="center">用户目录的爹目录</td></tr><tr><td align="left">/lib</td><td align="center">共享库</td></tr><tr><td align="left">/lib/modules</td><td align="center">可加载的内核模块</td></tr><tr><td align="left">/mnt</td><td align="center">临时挂载文件系统的挂载点</td></tr><tr><td align="left">/opt</td><td align="center">可选的插件软件包</td></tr><tr><td align="left">/proc</td><td align="center">虚拟文件系统的内核和进程信息</td></tr><tr><td align="left">/root</td><td align="center">root账户的主目录</td></tr><tr><td align="left">/sbin</td><td align="center">基本的二进制系统文件</td></tr><tr><td align="left">/sys</td><td align="center">设备的伪文件系统</td></tr><tr><td align="left">/tmp</td><td align="center">临时文件夹</td></tr><tr><td align="left">/usr</td><td align="center">辅助层次结构</td></tr><tr><td align="left">/usr/bin</td><td align="center">大多数的用户命令</td></tr><tr><td align="left">/usr/game</td><td align="center">游戏和教学程序</td></tr><tr><td align="left">/usr/include</td><td align="center">c程序包含的头文件</td></tr><tr><td align="left">/usr/lib</td><td align="center">库</td></tr><tr><td align="left">/usr/local</td><td align="center">本地层次结构</td></tr><tr><td align="left">/usr/sbin</td><td align="center">用于系统管理的次要二进制文件</td></tr><tr><td align="left">/usr/share</td><td align="center">与体系结构无关的数据</td></tr><tr><td align="left">/var</td><td align="center">变量数据，系统运行时内容会改变的文件，像是日志文件啦，临时文件啦等等</td></tr><tr><td align="left">## 访问权限</td><td align="center"></td></tr><tr><td align="left"><strong>ls -l</strong></td><td align="center"></td></tr><tr><td align="left">+ 显示访问权限</td><td align="center"></td></tr><tr><td align="left"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ ls -l</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-rw- 1 gss gss  34 Oct 15 19:29 gss</span><br><span class="line">-rw-rw-rw- 1 gss gss  75 Oct 15 19:40 gss2.bz2</span><br><span class="line">-rw-rw-rw- 1 gss gss   0 Oct 15 20:30 sfile</span><br><span class="line">-rw-rw-rw- 1 gss gss 476 Oct 15 20:33 typescript</span><br></pre></td></tr></table></figure></td><td align="center"></td></tr></tbody></table><ul><li>第一个字符是文件类型，普通文件是-,目录文件是d</li><li>后九个是访问权限</li><li>链接数目</li><li>所有者</li><li>组用户（对文件有访问权限的组）</li><li>文件大小</li><li>时间戳</li><li>文件名</li></ul><p><strong>chmod</strong></p><ul><li>改变文件权限</li><li>具有root权限的用户可以访问任何文件</li><li>读写执行（4+2+1）<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2></li><li>链接表示指向文件的指针</li><li>链接共有两种：硬链接和符号链接（软连接），硬链接较老，已经过时啦</li><li>创建硬链接 In file /lujing/mingzi</li><li>软链接的优点：可以指向不存在的文件，如果有一个文件删除了，然后重新创建了，那么软连接还可以指向这个新创建的文件。硬链接就只能一直指向那个旧的链接</li><li>包含-s或是–symbolc的In命令可以创建一个符号链接</li><li>使用rm删除链接<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><h2 id="执行命令行"><a href="#执行命令行" class="headerlink" title="执行命令行"></a>执行命令行</h2></li></ul><p><strong>进程</strong></p><ul><li>如果shell找到了与命令行上的命令具有相同名称的可执行文件，那么shell将启动一个新的进程，并且将命令行上的参数，命令名，传给调用的程序，所有的错误信息或者是返回信息都是程序的，有的程序会忽略错误的东东。<h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2></li></ul><p><strong>标准输入</strong></p><ul><li>是程序或者命令获得数据信息的地方</li></ul><p><strong>标准输出</strong></p><ul><li>是程序输出输出数据的地方</li><li>在linux中，各种设备是被当做文件进行读取或者写入的，都挂在dev的下面。</li><li>以cat为例，如果cat file那么file将会被cat当做是他的输入，如果cat后面没有参数，那么cat将会从标准输入中获得输入，就是默认的键盘，因此，输入一些东西之后按回车，cat将会把输入的东西打印出来。<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2></li></ul><p><strong>标准输出的重定向</strong></p><ul><li>符号：&gt;</li><li>可以使shell将命令的输出重定向到指定的文件而不是屏幕</li><li>如 ls -l &gt;filename</li><li>注意，如果文件已经存在那么会覆盖掉</li><li>使用&gt;&gt;符号可以向文件尾部追加信息</li></ul><p><strong>标准输入的重定向</strong></p><ul><li>符号： &lt;</li><li>使用这个可以让shell把命令的输入重定向到指定的文件而不是键盘，</li><li>如 cat &lt; filenaem</li></ul><p><strong>/dev/null</strong></p><ul><li>垃圾桶，可以把不想看到的或是不想保存的数据重新定位到这里来，就销毁了<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2>shell使用管道将一条命令的标准输出作为另一条命令的标准输入。<br>语法格式有提到过：command_a something | command_b</li></ul><p><strong>过滤器</strong></p><ul><li>filter是将输入数据流处理后再输出数据流的一类命令。</li><li>像who|sort|lpr这条命令中，把who的结果sort之后给打印机，那么sort就是一个过滤器</li></ul><p><strong>tee</strong></p><ul><li>tee 可以把标准输入复制到文件和标准输出，只有一个输入，但是双向输出</li><li>如 who| tee who.out|grep root<h2 id="后台运行程序"><a href="#后台运行程序" class="headerlink" title="后台运行程序"></a>后台运行程序</h2></li></ul><p><strong>作业</strong></p><ul><li>是指一系列的命令组成的序列，前台只能有一个作业位于窗口或是屏幕中，但是后台可以有很多作业运行，同一时间运行多个作业是linux的重要特性，这常称为多任务特性</li></ul><p><strong>作业编号与PID</strong></p><ul><li>在命令行的末尾输入&amp;后回车，那么该作业就会转为后台作业，linux会给他分配一个PID</li><li>当该作业运行结束的时候，shell会显示一条信息，这条信息的内容是已结束的作业PID和该命令的结果<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ ll &amp;</span><br><span class="line">[1] 30</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ total 16</span><br><span class="line">drwxr-xr-x 1 gss  gss   512 Oct 15 20:43 ./</span><br><span class="line">drwxr-xr-x 1 root root  512 Oct 15 17:41 ../</span><br><span class="line">-rw------- 1 gss  gss  1066 Oct 15 21:46 .bash_history</span><br><span class="line">-rw-r--r-- 1 gss  gss   220 Oct 15 17:41 .bash_logout</span><br><span class="line">-rw-r--r-- 1 gss  gss  3771 Oct 15 17:41 .bashrc</span><br><span class="line">-rw-r--r-- 1 gss  gss   807 Oct 15 17:41 .profile</span><br><span class="line">-rw------- 1 gss  gss  1226 Oct 15 20:35 .viminfo</span><br><span class="line">-rw-rw-rw- 1 gss  gss    34 Oct 15 19:29 gss</span><br><span class="line">-rw-rw-rw- 1 gss  gss    75 Oct 15 19:40 gss2.bz2</span><br><span class="line">-rw-rw-rw- 1 gss  gss     0 Oct 15 20:30 sfile</span><br><span class="line">-rw-rw-rw- 1 gss  gss   476 Oct 15 20:33 typescript</span><br></pre></td></tr></table></figure></li></ul><p><strong>后台转前台</strong></p><ul><li>输入fg可以把后台唯一的作业转到前台，如果fg后面跟了参数，那么就是PID的作业会被转到前台</li></ul><p><strong>kill</strong></p><ul><li>终止后台作业，输入kill和PID终止该进程</li></ul><p><strong>ps</strong></p><ul><li><p>确定PID</p></li><li><p>如，使用tail -f outfile,监视gss,把它放到后台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ tail -f gss&amp;</span><br><span class="line">[1] 32</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ 各位小伙伴们大家好呀</span><br></pre></td></tr></table></figure></li><li><p>ps一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    7 tty1     00:00:00 bash</span><br><span class="line">   32 tty1     00:00:00 tail</span><br><span class="line">   50 tty1     00:00:00 ps</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li><li><p>kill 一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gss@DESKTOP-4H90EP2:~$ <span class="built_in">kill</span> 32</span><br><span class="line">gss@DESKTOP-4H90EP2:~$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    7 tty1     00:00:00 bash</span><br><span class="line">   51 tty1     00:00:00 ps</span><br><span class="line">[1]+  Terminated              tail -f gss</span><br><span class="line">gss@DESKTOP-4H90EP2:~$</span><br></pre></td></tr></table></figure></li></ul><p>目前这篇博文就到这里啦，关于vim和一些命令的总结会有单独的文章出来的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/15/linux学习篇/linux.jpg&quot; alt=&quot;linux&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java基础</title>
    <link href="http://yoursite.com/2019/10/11/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/10/11/java基础/</id>
    <published>2019-10-11T03:06:31.000Z</published>
    <updated>2019-10-11T04:15:27.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/11/java基础/fengmian.jpg" alt="封面"></p><a id="more"></a><h2 id="java类的修饰词"><a href="#java类的修饰词" class="headerlink" title="java类的修饰词"></a>java类的修饰词</h2><p>有 public ,private,protected,default<br><img src="/2019/10/11/java基础/zuyongyu.png" alt="修饰词作用域"></p><ul><li>public：无论是否在同一个包，谁都可以访问</li><li>protected:只有自己包的类，或是别的包的子类可以访问，别的包的非子类是不可以访问的，</li><li>default:当前类和同个包的文件可以访问。别的包不可以访问</li><li>private:只要自己才可以访问。只有内部类菜会用到但是不建议这么写<h2 id="成员变量修饰符"><a href="#成员变量修饰符" class="headerlink" title="成员变量修饰符"></a>成员变量修饰符</h2></li><li>public：指定该变量为公共的他可以被任何对象的方法访问</li><li>private：指定该变量只允许自己的类的方法访问，其他任何类中的方法（包括子类）都不能访问</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/11/java基础/fengmian.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>linux命令总结篇</title>
    <link href="http://yoursite.com/2019/10/09/linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/10/09/linux命令/</id>
    <published>2019-10-09T12:23:16.000Z</published>
    <updated>2019-10-16T03:33:15.511Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/linux命令/feiji.jpg" alt="赛博朋克儿"></p><a id="more"></a><h2 id="开关机"><a href="#开关机" class="headerlink" title="开关机"></a>开关机</h2><p>1.sync:把内存中的数据写到硬盘中(每次关机之前重启之前都要执行)<br>2.shutdown -r now或rebot:立刻重启<br>3.shutdown -h now：立刻关机<br>4.shutdown -h 20:00 预定时间关机，如果今天过了预定的时间则明天这个时候关机<br>5.shutdown -h +10:预定时间关机，10分钟后关机。<br>6.shutdown -c:取消关机</p><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p>1.who am i:查看当前使用的终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@izwz9938t1plpjtmzr7adqz ~]<span class="comment"># who am i</span></span><br><span class="line">root     pts/0        2019-10-09 21:16 (117.152.78.143)</span><br></pre></td></tr></table></figure><p>2.who 或 w :查看所有终端<br>3.uname -m:显示机器的处理器架构<br>4.cat/proc/version 查看linux版本信息<br>5.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/linux命令/feiji.jpg&quot; alt=&quot;赛博朋克儿&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java内存模型</title>
    <link href="http://yoursite.com/2019/10/09/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/09/java内存模型/</id>
    <published>2019-10-09T11:34:46.000Z</published>
    <updated>2019-10-19T13:19:04.115Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/java内存模型/mei.jpg" alt="wind"></p><a id="more"></a><p><img src="/2019/10/09/java内存模型/jvm.jpg" alt="jvm"></p><ol><li>程序计数器：线程私有，记录的是正在执行的虚拟机字节码指令的地址。如果执行的是Native方法，则这个计数器的值为（undefined）,这是jvm中唯一一个不会有内存溢出的错误的区域</li><li>虚拟机栈：线程私有，生命周期和线程一致，描述的是java方法的内存模型，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表操作数栈，动态链接，方法出口等消息，每个方法从调用到执行结束，都是对应着一个栈帧从虚拟机中从入栈到出栈的过程。可能出现的错误：1. StackOverflowError(请求的栈的深度大于虚拟机的规定的栈的深度)2. OutOfMemoryError(虚拟机无法申请到足够的内存)</li><li>java堆：jvm中最大的一块儿，线程共享，主要是存放实例对象和数组。内部可以划分出多个线程私有的分配缓冲区，可以物理上不连续但是逻辑结构上需要连续。</li><li>java本地方法栈：为虚拟机使用到的本地方法服务，也会有StackOverflowError和OutOfMemoryError</li><li>方法区：属于共享内存区域，存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</li><li>运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，编译期和运行期（Sting的intern（）都可以将常量放到内存中）</li></ol><h1 id="java类加载机制"><a href="#java类加载机制" class="headerlink" title="java类加载机制"></a>java类加载机制</h1><ol><li>类加载器作用<br>类加载器本身作用就是用于加载类的，将类转换成java.lang.Class的实例；类加载器是通过类的全限定名来获取类的二进制字节流进而实现加载类。当我们比较两个类是否相等的时候，首先必须要确认是否由同一个类加载器加载，否则就算是使用相同class文件，被不同加载器加载比较结果还是不相等的。（相等可以指equals方法、isAssignableFrom方法、isInstance方法、instanceof方法等）。</li><li>有哪些</li></ol><ul><li><p><strong>BootStrap ClassLoader</strong>：称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等。</p></li><li><p><strong>Extension ClassLoader</strong>：称为扩展类加载器，负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。</p></li><li><p><strong>App ClassLoader</strong>：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</p></li><li><p><strong>CustomClassLoader</strong>： 用户自定义类加载器，对于用户自定义的加载器，不管你是直接实现ClassLoader,还是继承URLClassLoader,或者其他的子类。它的父类加载器都是AppClassLoader ，因为不管调用哪个父类构造器，创建的对象都必须最终调用getSystemClassLoader()作为父加载器，而getSystemClassLoader()方法获取到的正是AppClassLoader 。</p></li></ul><ol start="3"><li>当JVM运行过程中，用户需要加载某些类时，会按照下面的步骤（父类委托机制）：</li></ol><ul><li>用户自己的类加载器，把加载请求传给父加载器，父加载器再传给其父加载器，一直到加载器树的顶层。</li><li>最顶层的类加载器首先针对其特定的位置加载，如果加载不到就转交给子类。</li><li>如果一直到底层的类加载都没有加载到，那么就会抛出异常ClassNotFoundException。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/java内存模型/mei.jpg&quot; alt=&quot;wind&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat的面经</title>
    <link href="http://yoursite.com/2019/10/09/Tomcat%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2019/10/09/Tomcat的面经/</id>
    <published>2019-10-09T07:21:07.000Z</published>
    <updated>2019-10-09T11:09:38.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/Tomcat的面经/fan.jpg" alt="饭"> <img src="/2019/10/09/Tomcat的面经/fou.jpg" alt="fou"></p><a id="more"></a><p>总结一些从网上找到的各种有关于Tomcat的面试题目，做一个记忆</p><h2 id="Tomcat的缺省端口是多少，要怎么修改"><a href="#Tomcat的缺省端口是多少，要怎么修改" class="headerlink" title="Tomcat的缺省端口是多少，要怎么修改"></a>Tomcat的缺省端口是多少，要怎么修改</h2><p>缺省端口：8080<br>在conf文件夹中更改Host中的Connector的相关属性，端口号改成你需要的端口号码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="tomcat有几种部署方式"><a href="#tomcat有几种部署方式" class="headerlink" title="tomcat有几种部署方式"></a>tomcat有几种部署方式</h2><ul><li><p>直接把项目war包放在webapps目录下Tomcat会自动部署</p></li><li><p>在Server.xml中配置Context节点。</p></li><li><p>通过Catalina来进行配置：就是 cd 到 /usr/local/tomcat/apache-tomcat/conf/catatlina/localhost目录下，创建一个xml文件，该文件名字就是站点的名字，通过编写xml的方式来配置站点</p><h2 id="tomcat有哪几种Connector运行模式（以及各种模式优化方法）"><a href="#tomcat有哪几种Connector运行模式（以及各种模式优化方法）" class="headerlink" title="tomcat有哪几种Connector运行模式（以及各种模式优化方法）"></a>tomcat有哪几种Connector运行模式（以及各种模式优化方法）</h2><p>总共有三种运行模式<br>bio,nio,aio(nio.2),apr</p></li><li><p>传统的bio,同步阻塞的链接方式</p></li><li><p>设置maxThread属性的值//tomcatConnector使用的是多线程的模式，根据每台计算机的性能和内存大小不一样，一般可以放到400-500，最大可以放到800，默认只有两百</p></li><li><p>设置connector的maxSpareThreads属性，设置当线程超过某个值，tomcat就关闭不再需要的socket线程，默认50</p></li><li><p>acceptcount，指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数值的请求将不再被处理</p></li><li><p>ConnectionTimeout属性：网络连接超时的时间默认20000毫秒，可以设置为30000毫秒</p></li><li><p>进阶的nio(同步阻塞的io)</p></li><li><p>指定使用NIO模型来接受HTTP请求 nio或是aio</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protocol=”org.apache.coyote.http11.Http11NioProtocol” 指定使用NIO模型来接受HTTP请求。默认是BlockingIO，配置为protocol=”HTTP/1.1” </span><br><span class="line">acceptorThreadCount=”2” 使用NIO模型时接收线程的数目</span><br></pre></td></tr></table></figure></li><li><p>apr模式（我不太了解的模式，才知道。。。）</p></li><li><p>Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地 提高Tomcat对静态文件的处理性能。（额，对于动静分离的项目，布吉岛有什么用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      &lt;Connector connectionTimeout="20000" port="8000" protocol="HTTP/1.1" redirectPort="8443" uriEncoding="utf-8"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- protocol 启用 nio模式，(tomcat8默认使用的是nio)(apr模式利用系统级异步io) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- minProcessors最小空闲连接线程数--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- maxProcessors最大连接线程数--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- acceptCount允许的最大连接数，应大于等于maxProcessors--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- enableLookups 如果为true,requst.getRemoteHost会执行DNS查找，反向解析ip对应域名或主机名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">redirectPort</span>=<span class="string">"8443</span></span></span><br><span class="line"><span class="tag"><span class="string">        maxThreads=“500” </span></span></span><br><span class="line"><span class="tag"><span class="string">        minSpareThreads=“100” </span></span></span><br><span class="line"><span class="tag"><span class="string">        maxSpareThreads=“200”</span></span></span><br><span class="line"><span class="tag"><span class="string">        acceptCount="</span><span class="attr">200</span>"</span></span><br><span class="line"><span class="tag">        <span class="attr">enableLookups</span>=<span class="string">"false"</span>       </span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="tomcat容器是如何创建servlet实例的？用到了什么原理？"><a href="#tomcat容器是如何创建servlet实例的？用到了什么原理？" class="headerlink" title="tomcat容器是如何创建servlet实例的？用到了什么原理？"></a>tomcat容器是如何创建servlet实例的？用到了什么原理？</h2><p>当容器启动的时候，会读取项目中的web.xml读取servlet注册信息，然后将每个应用注册的servlet都进行加载，通过反射的方式实例化</p><h2 id="tomcat怎么优化"><a href="#tomcat怎么优化" class="headerlink" title="tomcat怎么优化"></a>tomcat怎么优化</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">优化连接配置.这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，修改连接数，关闭客户端dns查询。</span><br><span class="line"></span><br><span class="line">参数解释：</span><br><span class="line"></span><br><span class="line">URIEncoding=”UTF-8″ :使得tomcat可以解析含有中文名的文件的url，真方便，不像apache里还有搞个mod_encoding，还要手工编译</span><br><span class="line"></span><br><span class="line">maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。</span><br><span class="line"></span><br><span class="line">minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。</span><br><span class="line"></span><br><span class="line">enableLookups : 这个功效和Apache中的HostnameLookups一样，设为关闭。</span><br><span class="line"></span><br><span class="line">connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。</span><br><span class="line"></span><br><span class="line">maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。</span><br><span class="line"></span><br><span class="line">acceptCount : acceptCount是当线程数达到maxThreads后，后续请求会被放入一个等待队列，这个acceptCount是这个队列的大小，如果这个队列也满了，就直接refuse connection</span><br><span class="line"></span><br><span class="line">maxProcessors与minProcessors : 在 Java中线程是程序运行时的路径，是在一个程序中与其它控制线程无关的、能够独立运行的代码段。它们共享相同的地址空间。多线程帮助程序员写出CPU最 大利用率的高效程序，使空闲时间保持最低，从而接受更多的请求。</span><br><span class="line"></span><br><span class="line">通常Windows是1000个左右，Linux是2000个左右。</span><br><span class="line">可以看到如果把useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。</span><br><span class="line"></span><br><span class="line">enableLookups=”false” ： 为了消除DNS查询对性能的影响我们可以关闭DNS查询，方式是修改server.xml文件中的enableLookups参数值。</span><br><span class="line"></span><br><span class="line">disableUploadTimeout ：类似于Apache中的keeyalive一样</span><br><span class="line"></span><br><span class="line">给Tomcat配置gzip压缩(HTTP压缩)功能</span><br><span class="line"></span><br><span class="line">compression=”on” compressionMinSize=”2048″</span><br><span class="line"></span><br><span class="line">compressableMimeType=”text/html,text/xml,text/JavaScript,text/css,text/plain”</span><br><span class="line"></span><br><span class="line">HTTP 压缩可以大大提高浏览网站的速度，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览。相对于普通的浏览过程HTML,CSS,javascript , Text ，它可以节省40%左右的流量。更为重要的是，它可以对动态生成的，包括CGI、PHP , JSP , ASP , Servlet,SHTML等输出的网页也能进行压缩，压缩效率惊人。</span><br><span class="line"></span><br><span class="line">1)compression=”on” 打开压缩功能</span><br><span class="line"></span><br><span class="line">2)compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB</span><br><span class="line"></span><br><span class="line">3)noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩</span><br><span class="line"></span><br><span class="line">4)compressableMimeType=”text/html,text/xml”　压缩类型</span><br></pre></td></tr></table></figure><h2 id="tomcat-内存调优"><a href="#tomcat-内存调优" class="headerlink" title="tomcat 内存调优"></a>tomcat 内存调优</h2><p>内存的调整是在catalina.sh中的调整一下java_opts变量</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内存方式的设置是在catalina.sh中，调整一下JAVA_OPTS变量即可，因为后面的启动参数会把JAVA_OPTS作为JVM的启动参数来处理。 </span><br><span class="line">具体设置如下： </span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4" </span><br><span class="line">其各项参数如下： </span><br><span class="line">-Xmx3550m：设置JVM最大可用内存为3550M。 </span><br><span class="line">-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 </span><br><span class="line">-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 </span><br><span class="line">-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 </span><br><span class="line">-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 </span><br><span class="line">-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 </span><br><span class="line">-XX:MaxPermSize=16m:设置持久代大小为16m。 </span><br><span class="line">-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br></pre></td></tr></table></figure><h2 id="tomcat-垃圾回收"><a href="#tomcat-垃圾回收" class="headerlink" title="tomcat 垃圾回收"></a>tomcat 垃圾回收</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 </span><br><span class="line">-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 </span><br><span class="line">-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 </span><br><span class="line">-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 </span><br><span class="line">-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 </span><br><span class="line">并发收集器（响应时间优先） </span><br><span class="line">示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 </span><br><span class="line">-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 </span><br><span class="line">-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 </span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</span><br></pre></td></tr></table></figure><h2 id="怎么监视Tomcat的内存使用情况"><a href="#怎么监视Tomcat的内存使用情况" class="headerlink" title="怎么监视Tomcat的内存使用情况"></a>怎么监视Tomcat的内存使用情况</h2><p> 使用jdk自带的jconsole可以比较明了的看到内存的使用情况，线程的状态，当前加载的类的总量等。<br> 还可以下载Gc来看更详细的的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/Tomcat的面经/fan.jpg&quot; alt=&quot;饭&quot;&gt; &lt;img src=&quot;/2019/10/09/Tomcat的面经/fou.jpg&quot; alt=&quot;fou&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="http://yoursite.com/2019/10/09/Tomcat/"/>
    <id>http://yoursite.com/2019/10/09/Tomcat/</id>
    <published>2019-10-09T05:04:16.000Z</published>
    <updated>2019-10-09T07:06:01.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/10/09/Tomcat/tom.png" alt="tomcat"></p><a id="more"></a><h2 id="什么是Tomcat"><a href="#什么是Tomcat" class="headerlink" title="什么是Tomcat"></a>什么是Tomcat</h2><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，也是一个Servlet/JSP容器。Tomcat作为Servlet容器，负责处理客户端请求，把请求传送给Servlet，并将Servlet的响应返回给客户端。同时也具备处理静态页面的能力。多与Apache或是nginx搭配使用</p><h2 id="Tomcat的构成和处理请求的流程"><a href="#Tomcat的构成和处理请求的流程" class="headerlink" title="Tomcat的构成和处理请求的流程"></a>Tomcat的构成和处理请求的流程</h2><ul><li><p>Tomcat是一个基于组件的服务器，它的构成组件都是可配置的。其各个组件都在Tomcat安装目录下的../conf/server.xml文件中配置。</p></li><li><p>通过之后的配置文件的源码解读，我们将会了解到tomcat的核心组件主要有两个，一个是Connector,还有一个是Container</p></li><li><p>根据我的理解就是，connector负责在某一个指定的端口上面监听客户的请求，接受浏览器发过来的tcp链接请求，创建一个request和response对象负责交换数据，然后会产生一个线程来处理这个请求，并把这两个对象传给Engine,从Engine中获得相应再传给客户端。多线程的思想是Connector设计的核心。</p></li><li><p>而container是什么呢？就是容器的父接口，简单理解的话就是搭载了servlet应用程序的地方。他的体系结构如下图<br><img src="/2019/10/09/Tomcat/jiegou.jpg" alt="jiegou"></p></li><li><p>是一个责任链的设计模式主要由4个子容器组件构成，分别是Engine,Host,Context,Wrapper</p><ol><li>Engine容器比较简单，定义了一些基本的关联关系链接到host容器。</li><li>Host是Engine容器的子容器，一个Host在Engine中代表着一个虚拟主机。这个虚拟主机的作用就是运行多个应用，他负责安装和展开这些应用。并且标识这个应用以便能够区分它们，他的子容器通常是Context它除了关联子容器之外还有一些主机的相关的信息。</li><li>Context代表了servlet的Context，他具备了servlet运行的基本条件，理论上有了context就可以运行servlet了，他最重要的功能就是管理里面的servlet实例，而servlet的实例在Context中是以wrapper的形式出现的。Context通过request来找到对应的wrapper来执行。</li><li>Wrapper，代表了一个servlet的实例，负责管理一个servlet的生命周期，包括装载，初始化，执行，以及资源的回收，他的实现类是StandardWrapper，他实现了一个初始servlet的信息类servletconfig。wrapper就是tomcat的最底层了，他没有子容器。</li></ol></li><li><p>除此之外，Tomcat中还有其他重要的组件，如安全组件security、logger日志组件、session、mbeans、naming等其他组件。这些组件共同为Connector和Container提供必要的服务。</p></li><li><p>接下来我们模拟一下当有一个请求来到tomcat时会发生什么<br><img src="/2019/10/09/Tomcat/liucheng.jpg" alt="流程"></p><ol><li>用户在浏览器中输入网址localhost:8080/test/index.jsp，请求被发送到本机端口8080，被在那里监听的Coyote HTTP/1.1 Connector获得；</li><li>Connector把该请求交给它所在的Service的Engine（Container）来处理，并等待Engine的回应；</li><li>Engine获得请求localhost/test/index.jsp，匹配所有的虚拟主机Host；</li><li>.Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机），名为localhost的Host获得请求/test/index.jsp，匹配它所拥有的所有Context。Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为“ ”的Context去处理）；</li><li>path=“/test”的Context获得请求/index.jsp，在它的mapping table中寻找出对应的Servlet。Context匹配到URL Pattern为*.jsp的Servlet，对应于JspServlet类；</li><li>程序地干活</li><li>Context把执行完之后的HttpServletResponse对象返回给Host</li><li>层层返回</li></ol></li></ul><h2 id="配置文件的用途和含义"><a href="#配置文件的用途和含义" class="headerlink" title="配置文件的用途和含义"></a>配置文件的用途和含义</h2><p><img src="/2019/10/09/Tomcat/peizhi.png" alt="peizhi"><br>可以看到有Context.xml,Server.xml,tomcat-users.xml,以及web.xml这些配置文件。</p><h3 id="Context-xml文件解释"><a href="#Context-xml文件解释" class="headerlink" title="Context.xml文件解释"></a>Context.xml文件解释</h3><p>首先需要明确Context.xml是做什么的，他是Tomcat公用的环境配置文件，tomcat会定时的去扫描这个文件，发现文件被修改了之后（时间戳改变）就会自动的重新加载这个文件，而不需要重启tomcat，推荐在$CATALINA_BASEconf/context.xml进行独立配置。就是说在单独的context中进行配置而不在server.xml中去做配置。因为server.xml是不可动态加载的资源。要重启服务器才可以重新加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/eml"</span> <span class="attr">docBase</span>=<span class="string">"eml"</span> <span class="attr">debug</span>=<span class="string">"0"</span> <span class="attr">reloadbale</span>=<span class="string">"true"</span> <span class="attr">privileged</span>=<span class="string">"true"</span>&gt;</span>  </span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/web.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span>  </span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchedResource</span>&gt;</span>WEB-INF/eml.xml<span class="tag">&lt;/<span class="name">WatchedResource</span>&gt;</span> #监控资源文件，如果web.xml || eml.xml改变了，则自动重新加载改应用。  </span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"jdbc/testSiteds"</span> 　　#表示指定的<span class="attr">jndi</span>名称  </span></span><br><span class="line"><span class="tag">    <span class="attr">auth</span>=<span class="string">"Container"</span> 　　#表示认证方式，一般为<span class="attr">Container</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">"javax.sql.DataSource"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">maxActive</span>=<span class="string">"100"</span> 　　#连接池支持的最大连接数  </span></span><br><span class="line"><span class="tag">    <span class="attr">maxIdle</span>=<span class="string">"40"</span> 　　　　#连接池中最多可空闲<span class="attr">maxIdle</span>个连接  </span></span><br><span class="line"><span class="tag">    <span class="attr">maxWait</span>=<span class="string">"30000"</span> 　　#连接池中连接用完时,新的请求等待时间,毫秒  </span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">"txl"</span> 　　　#表示数据库用户名  </span></span><br><span class="line"><span class="tag">    <span class="attr">password</span>=<span class="string">"123456"</span> 　　#表示数据库用户的密码  </span></span><br><span class="line"><span class="tag">    <span class="attr">driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span> 　　#表示<span class="attr">JDBC</span> <span class="attr">DRIVER</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost:3306/testSite"</span> /&gt;</span> 　　#表示数据库URL地址  </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><p>context.xml的三个作用范围</p><ul><li>tomcat server级别：  在/conf/context.xml里配置</li><li>Host级别：  在/conf/Catalina/${hostName}里添加context.xml，继而进行配置</li><li>web app 级别：  在/conf/Catalina/${hostName}里添加${webAppName}.xml，继而进行配置</li></ul><h3 id="Server-xml文件解释"><a href="#Server-xml文件解释" class="headerlink" title="Server.xml文件解释"></a>Server.xml文件解释</h3><p>server.xml是对tomcat的设置，可以设置端口号，添加虚拟机这些的，是对服务器的设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 全局命名资源，来定义一些外部访问资源，其作用是为所有引擎应用程序所引用的外部资源的定义 --!&gt; </span></span><br><span class="line"><span class="comment">    &lt;Resource name="UserDatabase" auth="Container"</span></span><br><span class="line"><span class="comment">              type="org.apache.catalina.UserDatabase"</span></span><br><span class="line"><span class="comment">              description="User database that can be updated and saved"</span></span><br><span class="line"><span class="comment">              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span><br><span class="line"><span class="comment">              pathname="conf/tomcat-users.xml" /&gt;</span></span><br><span class="line"><span class="comment">  &lt;/GlobalNamingResources&gt;</span></span><br><span class="line"><span class="comment">  &lt;Service name="Catalina"&gt;</span></span><br><span class="line"><span class="comment">      &lt;Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; </span></span><br><span class="line"><span class="comment">   &lt;!-- 修改HTTP/1.1的Connector监听端口为80.客户端通过浏览器访问的请求，只能通过HTTP传递给tomcat。还可以设置server与URIEncoding参数 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;Engine name="Catalina" defaultHost="test.com"&gt;--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 修改当前Engine，默认主机是，localhost  --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">   # Realm组件，定义对当前容器内的应用程序访问的认证，通过外部资源UserDatabase进行认证 </span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义了一个主机，域名是localhost，应用程序的目录是/webapps,设置自动部署解压--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"> &lt;!--   定义一个Valve组件，用来记录tomcat的访问日志，日志存放目录为：/web/www/logs如果定义为相对路径则是相当于$CATALINA_HOME，并非相对于appBase，这个要注意。定义日志文件前缀为www_access.并以.log结尾，pattern定义日志内容格式，具体字段表示可以查看tomcat官方文档   --&gt; </span><br><span class="line">               prefix="localhost_access_log" suffix=".txt"</span><br><span class="line">               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span><br><span class="line">   <span class="comment">&lt;!--可以在这里添加别名&lt;Alias&gt;www.test.com&lt;/Alias&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;Context path="" docBase="www/" reloadable="true" /&gt; </span></span><br><span class="line"><span class="comment">定义该应用程序，访问路径""，即访问www.test.com即可访问，网页目录为：相对于appBase下的www/，即/web/www，并且当该应用程序下web.xml或者类等有相关变化时，自动重载当前配置，即不用重启tomcat使部署的新应用程序生效  --&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">  Host name="manager.test.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; </span><br><span class="line">        <span class="comment">&lt;!--   定义一个主机名为man.test.com，应用程序目录是$CATALINA_HOME/webapps,自动解压，自动部署   --&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.RemoteAddrValve"</span> <span class="attr">allow</span>=<span class="string">"172.16.100.*"</span> /&gt;</span> </span><br><span class="line">          <span class="comment">&lt;!--   定义远程地址访问策略，仅允许172.16.100.*网段访问该主机，其他的将被拒绝访问  --&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"/web/bbs/logs"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">prefix</span>=<span class="string">"bbs_access."</span> <span class="attr">suffix</span>=<span class="string">".log"</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span> </span><br><span class="line">          <span class="comment">&lt;!--   定义该主机的访问日志      --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">Host</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个 server 有一个 service，一个 service 里有多个 connector 和一个 engine，不同的 connector 除了端口可能不同，协议也可能不同。多个connector 对应一个 engine。　　engine 代表我们应用程序的容器。一个 engine 中有一个到多个 host，一个host 代表我们的一个虚拟主机。host 里又有一个到多个 context，一个 context 代表了一个应用程序的虚拟子站点。</p><h3 id="tomcat-users-xml文件解释"><a href="#tomcat-users-xml文件解释" class="headerlink" title="tomcat-users.xml文件解释"></a>tomcat-users.xml文件解释</h3><p>这个是使用tomcatMannager才需要配置的属性。</p><h3 id="web-xml文件解释"><a href="#web-xml文件解释" class="headerlink" title="web.xml文件解释"></a>web.xml文件解释</h3><p>Web应用程序描述文件，都是关于是Web应用程序的配置文件。所有Web应用的 web.xml 文件的父文件。<br>这个文件是基本不用配置的，如果要支持cgi的话，要在这里面吧cgi的那一段儿注释掉。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/10/09/Tomcat/tom.png&quot; alt=&quot;tomcat&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
</feed>
